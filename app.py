import pandas as pd
from decimal import Decimal
import logging
from flask import Flask, render_template, request, redirect, flash, session, url_for, jsonify
from markupsafe import Markup
from flask_mail import Mail, Message
from db_utils import *
from encryption import encrypt_message, decrypt_message, generate_random_password
from datetime import datetime, date, timedelta
from werkzeug.utils import secure_filename
import os
import pytz
from dotenv import load_dotenv
load_dotenv()
# Get the current working directory
current_workspace = os.getcwd()

# Define the path for the uploads folder
UPLOAD_FOLDER = os.path.join(current_workspace, 'uploads')

# Create the uploads folder if it doesn't already exist
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

# ALLOWED_EXTENSIONS = {'txt', 'csv', 'xlsx'}

app = Flask(__name__)
app.secret_key = "your_secret_key"
encryption_key = b'ES4FoQd6EwUUUY3v-_WwoyYsBEYkWUTOrQD1VEngBkI='

app.logger.setLevel(logging.DEBUG)
# Mail configuration for Gmail
app.config['MAIL_SERVER'] = 'smtp.gmail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USERNAME'] = 'dharaniinventorysolution@gmail.com'  # Replace with your Gmail address
app.config['MAIL_PASSWORD'] = 'einudsafiqrrqlos'  # Replace with your Gmail app password
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USE_SSL'] = False

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB

mail = Mail(app)


@app.before_request
def make_session_permanent():
    session.permanent = True
    app.permanent_session_lifetime = timedelta(minutes=30)
# Send email function


def send_email(to_email, new_password):
    try:
        msg = Message(
            'Your New Password',
            sender='dharaniinventorysolution@gmail.com',
            recipients=[to_email]
        )
        msg.body = f"Your new password is: {new_password}\nPlease log in and change it immediately. This is a autogenerated mail. Please do not reply to this email."
        mail.send(msg)
    except Exception as e:
        print(f"Error sending email: {e}")
        raise e


def get_current_date():

    # Get the IST timezone
    ist_timezone = pytz.timezone('Asia/Kolkata')

    # Get current time in IST
    current_time_ist = datetime.now(ist_timezone)

    # Format the date as "YYYY-MM-DD"
    formatted_date_ist = current_time_ist.strftime("%Y-%m-%d")
    return formatted_date_ist


@app.route("/")
@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        email = request.form["email"].strip()
        password = request.form["password"].strip()
        existing_user = get_user_by_email(email)
        app.logger.debug(f"existing_user {existing_user}")
        if not existing_user:
            flash("User doesnot exist with this email. Please Sign Up and Create a new account.", "danger")
            return render_template("login.html")
        elif existing_user:
            if existing_user["status"] == "inactive":
                flash("User Account has been made Inactive. Kindy contact the Admin to activate the account.", "danger")
            else:
                decrypted_password = decrypt_message(existing_user["password"], encryption_key)
                existing_user.pop("password")
                if decrypted_password == password:
                    session['user'] = existing_user
                    return redirect("/index")
                else:
                    flash("Invalid Email or Password", "danger")
            return render_template("login.html")
    return render_template("login.html")


@app.route("/signup", methods=["GET", "POST"])
def signup():
    if request.method == "POST":
        username = request.form["username"].strip()
        email = request.form["email"].strip()
        password = request.form["password"].strip()
        # Check if the email is already registered

        existing_user = get_user_by_email(email)
        app.logger.debug(f"existing_user {existing_user}")

        if existing_user:
            # Email already exists
            flash("User already exists with this email. Please log in or use a different email.", "danger")
        else:
            password = encrypt_message(password, encryption_key)
            # Insert new user details
            insert_query = """
                INSERT INTO users (username, email, password, role) 
                VALUES (%s, %s, %s, %s)
            """
            if execute_query(insert_query, (username, email, password, "user")):
                flash("Account created successfully! Click Sign In to login with your account.", "success")
            else:
                flash("Error: Unable to create account. Please try again later.", "danger")

        return redirect("/signup")
    return render_template("signup.html")


@app.route("/index", methods=["GET", "POST"])
def index():
    if "user" not in session:
        return redirect("/login")
    cost_details = get_total_cost_stats()[0]
    return render_template("index.html", user=session["user"], cost_details=cost_details)


@app.route('/api/years', methods=['GET'])
def get_years():
    years = get_purchase_years()
    return jsonify(years)


@app.route("/forgotpassword", methods=["GET", "POST"])
def forgot_password():
    app.logger.debug(request.method)
    if request.method == 'POST':

        email = request.form['email']
        user = get_user_by_email(email)

        if user is None:
            flash('User with the entered email not found.', 'error')
            return redirect(url_for('forgot_password'))
        else:
            # Generate a new password
            new_password = generate_random_password()
            app.logger.debug(new_password)
            new_encrypted_password = encrypt_message(new_password, key=encryption_key)
            app.logger.debug(new_encrypted_password)
            # Update the password in the database
            status = update_user_password(new_encrypted_password, email)
            app.logger.debug(f"password update status {status}")
            # Send the email
            try:
                send_email(email, new_password)
                flash('An email has been sent with the new password. Please log in with the new password.', 'success')
            except Exception:
                flash('Failed to send email. Please contact support.', 'error')

            return redirect(url_for('forgot_password'))
    return render_template('forgotpassword.html')


@app.route("/changepassword", methods=["GET", "POST"])
def change_password():
    if "user" not in session:
        return redirect("/login")
    if request.method == 'POST':

        email = session["user"]['email']
        new_password = request.form["newpassword"]
        current_password = request.form["currentpassword"]
        user = get_user_by_email(email)
        if current_password != decrypt_message(user["password"], encryption_key):
            flash("Current password is wrong. kindly provide the correct password")
            return redirect(url_for("change_password"))
        else:
            app.logger.debug(new_password)
            new_encrypted_password = encrypt_message(new_password, key=encryption_key)
            app.logger.debug(new_encrypted_password)
            # Update the password in the database
            status = update_user_password(new_encrypted_password, email)
            app.logger.debug(f"password update status {status}")
            if status:
                flash('Password has been changed successfully.', 'success')
            else:
                flash('Failed to change the password. Please contact support.', 'error')
            return redirect(url_for("change_password"))

    return render_template('changepassword.html', user=session["user"])


@app.route("/addstorageroom", methods=["GET", "POST"])
def addstorageroom():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        storageroom_name = request.form["storageroom_name"].strip()
        address = request.form["address"].strip()
        existing_storageroom = get_storageroom_by_name(storageroom_name)
        if existing_storageroom:
            flash("Storage Room with same name already exists. Please use a different Storage Room Name.", "danger")
        else:
            insert_query = """
                INSERT INTO storagerooms (storageroomname, address)
                VALUES (%s, %s)
            """
            if execute_query(insert_query, (storageroom_name, address)):
                flash("Storage Room added successfully!", "success")
            else:
                flash("Error: Unable to add a new Storage Room. Please try again later.", "danger")
        return redirect("/addstorageroom")
    return render_template("addstorageroom.html", user=session["user"])


@app.route("/storageroomlist", methods=["GET", "POST"])
def storageroomlist():
    if "user" not in session:
        return redirect("/login")
    storagerooms = get_all_storagerooms()
    print(storagerooms)
    return render_template("storageroomlist.html", user=session["user"], storagerooms=storagerooms)


@app.route('/editstorageroom', methods=['POST'])
def edit_storage_room():
    # Get data from the form
    room_id = request.form.get('id')
    room_status = request.form.get('status')
    room_address = request.form.get('address')

    # Validate inputs
    if not room_id or not room_address:
        flash("All fields are required.", "error")
        return redirect(url_for('storage_rooms_list'))

    # SQL query to update the storage room
    query = """
        UPDATE storagerooms
        SET address = %s, status= %s
        WHERE id = %s
    """
    params = (room_address, room_status, room_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("Storage room details updated successfully.", "success")
    else:
        flash("Failed to update the storage room details. Please try again.", "danger")

    # Redirect back to the storage rooms list
    return redirect(url_for('storageroomlist'))


@app.route('/editkitchen', methods=['POST'])
def edit_kitchen():
    # Get data from the form
    kitchen_id = request.form.get('id')
    kitchen_status = request.form.get('status')
    kitchen_address = request.form.get('address')

    # Validate inputs
    if not kitchen_id or not kitchen_address:
        flash("All fields are required.", "error")
        return redirect(url_for('kitchenlist'))

    # SQL query to update the kitchen
    query = """
        UPDATE kitchen
        SET address = %s, status= %s
        WHERE id = %s
    """
    params = (kitchen_address, kitchen_status, kitchen_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("Kitchen details updated successfully.", "success")
    else:
        flash("Failed to update the Kitchen details. Please try again.", "danger")

    # Redirect back to the kitchen list
    return redirect(url_for('kitchenlist'))


@app.route('/editrestaurant', methods=['POST'])
def edit_restaurant():
    # Get data from the form
    restaurant_id = request.form.get('id')
    restaurant_status = request.form.get('status')
    restaurant_address = request.form.get('address')

    # Validate inputs
    if not restaurant_id or not restaurant_address:
        flash("All fields are required.", "error")
        return redirect(url_for('restaurantlist'))

    # SQL query to update the restaurant
    query = """
        UPDATE restaurant
        SET address = %s, status= %s
        WHERE id = %s
    """
    params = (restaurant_address, restaurant_status, restaurant_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("restaurant details updated successfully.", "success")
    else:
        flash("Failed to update the restaurant details. Please try again.", "danger")

    # Redirect back to the restaurant list
    return redirect(url_for('restaurantlist'))


@app.route('/editrawmaterial', methods=['POST'])
def edit_rawmaterial():
    # Get data from the form
    rawmaterial_id = request.form.get('id')
    rawmaterial_category = request.form.get('category')
    rawmaterial_metric = request.form.get('metric')
    # SQL query to update the rawmaterial
    query = """
        UPDATE raw_materials
        SET category = %s, metric= %s
        WHERE id = %s
    """
    params = (rawmaterial_category, rawmaterial_metric, rawmaterial_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("rawmaterial details updated successfully.", "success")
    else:
        flash("Failed to update the rawmaterial details. Please try again.", "danger")

    # Redirect back to the rawmaterial list
    return redirect(url_for('rawmaterialslist'))


@app.route('/edituser', methods=['POST'])
def edituser():
    # Get data from the form
    user_id = request.form.get('id')
    user_role = request.form.get('role')
    user_status = request.form.get('status')

    # Validate inputs
    if not user_id or not user_role or not user_status:
        flash("All fields are required.", "error")
        return redirect(url_for('userlist'))

    # SQL query to update the user
    query = """
        UPDATE users
        SET role = %s, status= %s
        WHERE id = %s
    """
    params = (user_role, user_status, user_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("user details updated successfully.", "success")
    else:
        flash("Failed to update the user details. Please try again.", "danger")

    # Redirect back to the user list
    return redirect(url_for('userlist'))


@app.route('/invoice_page')
def invoice_page():
    conn = get_db_connection()
    vendors = get_all_vendors()
    app.logger.debug(f"vvv {vendors}")
    app.logger.debug(session["user"])
    conn.close()
    return render_template('invoice.html', user=session["user"], vendors=vendors)


@app.route('/get_invoices/<vendor_id>')
def get_invoices(vendor_id):
    conn = get_db_connection()
    with conn.cursor() as cursor:
        cursor.execute("SELECT DISTINCT invoice_number FROM purchase_history WHERE vendor_id = %s", (vendor_id,))
        invoices = cursor.fetchall()
    conn.close()
    return jsonify(invoices)


# @app.route('/get_purchases/<invoice_number>')
# def get_purchases(invoice_number):
#     conn = get_db_connection()
#     with conn.cursor() as cursor:
#         cursor.execute("SELECT * FROM purchase_history WHERE invoice_number = %s", (invoice_number,))
#         purchases = cursor.fetchall()

#         cursor.execute(
#             "SELECT SUM(total_cost) AS total_amount FROM purchase_history WHERE invoice_number = %s", (invoice_number,))
#         total_amount = cursor.fetchone()["total_amount"]
#     conn.close()
#     return jsonify({"purchases": purchases, "total_amount": total_amount})


@app.route('/get_invoice_data', methods=['POST'])
def get_invoice_data():
    vendor_id = request.json.get('vendor_id')
    from_date = request.json.get('from_date')
    to_date = request.json.get('to_date')
    app.logger.debug(vendor_id)
    app.logger.debug(from_date)
    app.logger.debug(to_date)

    conn = get_db_connection()
    with conn.cursor() as cursor:
        cursor.execute("""
            SELECT purchase_date AS date, invoice_number AS type, invoice_number AS sr_no, '-' AS payment_mode,
                   total_cost AS credit, 0.0 AS debit, 0.0 AS balance
            FROM purchase_history
            WHERE vendor_id = %s AND purchase_date BETWEEN %s AND %s
            UNION ALL
            SELECT paid_on AS date, 'Payment Out' AS type, invoice_number AS sr_no, mode_of_payment AS payment_mode,
                   0.0 AS credit, amount_paid AS debit, 0.0 AS balance
            FROM payment_records
            WHERE vendor_id = %s AND paid_on BETWEEN %s AND %s
            ORDER BY date
        """, (vendor_id, from_date, to_date, vendor_id, from_date, to_date))
        transactions = cursor.fetchall()
        app.logger.debug(f"transactions {transactions}")
        cursor.execute("SELECT SUM(total_cost) AS total_credit FROM purchase_history WHERE vendor_id = %s AND purchase_date BETWEEN %s AND %s",
                       (vendor_id, from_date, to_date))
        total_credit = cursor.fetchone()[0]
        app.logger.debug(f"total_credit {total_credit}")
        cursor.execute("SELECT SUM(amount_paid) AS total_debit FROM payment_records WHERE vendor_id = %s AND paid_on BETWEEN %s AND %s",
                       (vendor_id, from_date, to_date))
        total_debit = cursor.fetchone()[0]
    conn.close()

    return jsonify({
        "transactions": transactions,
        "total_credit": total_credit,
        "total_debit": total_debit
    })
# @app.route('/invoice_page')
# def invoice_page():
#     return render_template('invoice.html')


# @app.route('/invoice_data')
# def get_invoice_data():
#     invoice_data = {
#         "company_name": "Noah Shipping Service",
#         "phone": "9987415544",
#         "report_title": "Party Ledger Report",
#         "date_range": "01-April-2024 - 31-March-2025",
#         "party_name": "Srp logistics (P) limited",
#         "gstin": "07AAHCS4054N1ZY",
#         "transactions": [
#             {"date": "19-June-2024", "type": "Purchase Bill", "sr_no": 17,
#                 "payment_mode": "-", "credit": 22819.93, "debit": 0.0, "balance": -22819.93},
#             {"date": "02-July-2024", "type": "Payment-out", "sr_no": 11,
#                 "payment_mode": "Online", "credit": 22819.93, "debit": 0.0, "balance": 0.0},
#             {"date": "05-August-2024", "type": "Purchase Bill", "sr_no": 27,
#                 "payment_mode": "-", "credit": 6465.66, "debit": 0.0, "balance": -6465.66},
#             {"date": "10-August-2024", "type": "Payment-out", "sr_no": 19,
#                 "payment_mode": "Online", "credit": 6465.66, "debit": 0.0, "balance": 0.0},
#             {"date": "26-December-2024", "type": "Purchase Bill", "sr_no": 49,
#                 "payment_mode": "Cash", "credit": 40853.37, "debit": 25000.0, "balance": -15853.37},
#             {"date": "09-January-2025", "type": "Payment-out", "sr_no": 37,
#                 "payment_mode": "Bank", "credit": 15853.37, "debit": 0.0, "balance": 0.0}
#         ],
#         "total_credit": 70138.96,
#         "total_debit": 70138.96
#     }
#     return jsonify(invoice_data)


@app.route('/editvendor', methods=['POST'])
def edit_vendor():
    # Get data from the form
    vendor_id = request.form.get('id')
    vendor_status = request.form.get('status')
    vendor_address = request.form.get('address')
    vendor_phone = request.form.get('phone')

    # Validate inputs
    if not vendor_id or not vendor_address or not vendor_phone:
        flash("All fields are required.", "error")
        return redirect(url_for('vendorlist'))

    # SQL query to update the vendor
    query = """
        UPDATE vendor_list
        SET address= %s, status= %s, phone=%s
        WHERE id = %s
    """
    params = (vendor_address, vendor_status, vendor_phone, vendor_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("vendor details updated successfully.", "success")
    else:
        flash("Failed to update the vendor details. Please try again.", "danger")

    # Redirect back to the vendor list
    return redirect(url_for('list_vendors'))


@app.route("/addkitchen", methods=["GET", "POST"])
def addkitchen():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        kitchen_name = request.form["kitchen_name"].strip()
        address = request.form["address"].strip()
        existing_kitchen = get_kitchen_by_name(kitchen_name)
        if existing_kitchen:
            flash("Kitchen with same name already exists. Please use a different Kitchen name.", "danger")
        else:
            insert_query = """
                INSERT INTO kitchen (kitchenname, address)
                VALUES (%s, %s)
            """
            if execute_query(insert_query, (kitchen_name, address)):
                flash("Kitchen added successfully!", "success")
            else:
                flash("Error: Unable to add a new Kitchen. Please try again later.", "danger")
        return redirect("/addkitchen")
    return render_template("addkitchen.html", user=session["user"])


@app.route("/kitchenlist", methods=["GET", "POST"])
def kitchenlist():
    if "user" not in session:
        return redirect("/login")
    kitchens = get_all_kitchens()
    return render_template("kitchenlist.html", user=session["user"], kitchens=kitchens)


@app.route("/addrestaurant", methods=["GET", "POST"])
def addrestaurant():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        restaurant_name = request.form["restaurant_name"].strip()
        address = request.form["address"].strip()
        existing_restaurant = get_restaurant_by_name(restaurant_name)
        if existing_restaurant:
            flash("Restaurant with same name already exists. Please use a different Restaurant name.", "danger")
        else:
            insert_query = """
                INSERT INTO restaurant (restaurantname, address)
                VALUES (%s, %s)
            """
            if execute_query(insert_query, (restaurant_name, address)):
                flash("Restaurant added successfully!", "success")
            else:
                flash("Error: Unable to add a new Restaurant. Please try again later.", "danger")
        return redirect("/addrestaurant")
    return render_template("addrestaurant.html", user=session["user"])


@app.route("/restaurantlist", methods=["GET", "POST"])
def restaurantlist():
    if "user" not in session:
        return redirect("/login")
    restaurants = get_all_restaurants()
    return render_template("restaurantlist.html", user=session["user"], restaurants=restaurants)


@app.route("/addrawmaterials", methods=["GET", "POST"])
def addrawmaterials():
    if "user" not in session:
        return redirect("/login")

    if request.method == "POST":
        raw_materials = request.form.getlist("rawmaterial_name[]")
        metrics = request.form.getlist("metric[]")
        categories = request.form.getlist("materialcategory")

        # Check for mismatched lengths (in case of any unexpected UI issues)
        if len(raw_materials) != len(metrics) and len(raw_materials) != len(categories):
            flash("Error: Inconsistent data. Please try again.", "danger")
            return redirect("/addrawmaterials")

        # Fetch all existing raw materials in one query
        existing_materials = get_all_rawmaterials()
        existing_set = {(row["name"].lower(), row["metric"].lower(), row["category"].lower())
                        for row in existing_materials}

        # Prepare data for bulk insert
        to_insert = []
        errors = []
        successes = []

        for raw_material, metric, category in zip(raw_materials, metrics, categories):
            raw_material = raw_material.strip().lower()
            metric = metric.strip().lower()
            category = category.strip().lower()

            if not raw_material:
                errors.append("Raw material name cannot be empty.")
                continue

            if (raw_material, metric, category) in existing_set:
                errors.append(
                    f"Raw material '{raw_material}' with metric '{metric}' under category '{category}' already exists.")
                continue

            # Add to batch insert list
            to_insert.append((raw_material, metric, category))

        # Perform bulk insert if there are valid entries
        if to_insert:
            insert_query = "INSERT INTO raw_materials (name, metric, category) VALUES (%s, %s, %s)"
            if execute_query(insert_query, to_insert, bulk=True):  # Pass `bulk=True` to handle batch inserts
                successes = [f"{raw_material}-{metric}-{category}" for raw_material, metric, category in to_insert]
            else:
                errors.append("Error: Unable to add some raw materials due to a database issue.")

        # Flash messages for successes and errors
        if successes:
            flash(f"Raw materials {' ,'.join(successes)} have been added successfully.", "success")
        if errors:
            flash(" ".join(errors), "danger")

        return redirect("/addrawmaterials")

    return render_template("addrawmaterials.html", user=session["user"])


@app.route("/rawmaterialslist", methods=["GET", "POST"])
def rawmaterialslist():
    if "user" not in session:
        return redirect("/login")
    rawmaterials = get_all_rawmaterials()
    return render_template("rawmaterialslist.html", user=session["user"], rawmaterials=rawmaterials)


@app.route('/add_dish_recipe', methods=['GET', 'POST'])
def add_dish_recipe():
    if "user" not in session:
        return redirect("/login")

    if request.method == 'POST':
        category = request.form['category']
        name = request.form['name']
        raw_materials = request.form.getlist('raw_materials[]')
        quantities = request.form.getlist('quantities[]')
        metrics = request.form.getlist('metric[]')

        if len(raw_materials) != len(quantities) or len(raw_materials) != len(metrics):
            flash("Error: Mismatched data for raw materials. Please check your input.", "danger")
            return redirect('/add_dish_recipe')

        # try:
        existing_dish = get_dish_details_from_category(category, name)
        if not existing_dish:
            with get_db_connection() as conn:
                with conn.cursor() as cursor:
                    # Insert into `dishes` table
                    cursor.execute("INSERT INTO dishes (category, name) VALUES (%s, %s)", (category, name))
                    dish_id = cursor.lastrowid

                    # Fetch all existing raw materials in one query
                    cursor.execute("SELECT id, name, metric FROM raw_materials")
                    existing_raw_materials = {row[1].lower(): (row[0], row[2])
                                              for row in cursor.fetchall()}

                    # Prepare data for batch inserts
                    new_raw_materials = []
                    dish_raw_materials = []

                    for raw_material, quantity, metric in zip(raw_materials, quantities, metrics):
                        raw_material = raw_material.strip().lower()
                        metric = metric.strip()

                        if raw_material in existing_raw_materials:
                            raw_material_id = existing_raw_materials[raw_material][0]
                        else:
                            # Add to new raw materials batch
                            new_raw_materials.append((raw_material, metric))

                    # Bulk insert new raw materials
                    if new_raw_materials:
                        cursor.executemany(
                            "INSERT INTO raw_materials (name, metric) VALUES (%s, %s)",
                            new_raw_materials
                        )
                        # Update existing_raw_materials with newly added materials
                        cursor.execute("SELECT id, name, metric FROM raw_materials WHERE name IN %s",
                                       ([rm[0] for rm in new_raw_materials],))
                        for row in cursor.fetchall():
                            existing_raw_materials[row['name'].lower()] = (row['id'], row['metric'])

                    # Build dish_raw_materials mapping
                    for raw_material, quantity, metric in zip(raw_materials, quantities, metrics):
                        raw_material_id = existing_raw_materials[raw_material][0]
                        dish_raw_materials.append((dish_id, raw_material_id, quantity, metric))

                    # Bulk insert into `dish_raw_materials`
                    cursor.executemany(
                        "INSERT INTO dish_raw_materials (dish_id, raw_material_id, quantity, metric) VALUES (%s, %s, %s, %s)",
                        dish_raw_materials
                    )

                conn.commit()
                flash('Dish added successfully!', 'success')
        else:
            flash('Dish already exists. Kindly check.', 'danger')

        # except Exception as e:
        #     flash(f'Error: {str(e)}', 'danger')

        return redirect('/add_dish_recipe')

    raw_materials = get_all_rawmaterials()
    dish_categories = get_all_dish_categories()

    return render_template('add_dish_recipe.html', user=session["user"], raw_materials=raw_materials, dish_categories=dish_categories)


@app.route('/list_dish_recipe', methods=['GET', 'POST'])
def list_dish_recipe():
    if "user" not in session:
        return redirect("/login")
    # Fetch dishes and their raw materials from the database
    query = """
        SELECT d.id, d.name AS dish_name, d.category,
               rm.name AS raw_material_name, dr.quantity, dr.metric
        FROM dishes d
        JOIN dish_raw_materials dr ON d.id = dr.dish_id
        JOIN raw_materials rm ON dr.raw_material_id = rm.id
        ORDER BY d.id, rm.name
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(query)
    data = cursor.fetchall()

    # Organize data into a dictionary grouped by dishes
    dishes = {}
    for row in data:
        dish_id, dish_name, category, raw_material_name, quantity, metric = row
        if dish_id not in dishes:
            dishes[dish_id] = {
                "name": dish_name,
                "category": category,
                "raw_materials": []
            }
        dishes[dish_id]["raw_materials"].append({
            "name": raw_material_name,
            "quantity": quantity,
            "metric": metric
        })

    return render_template('list_dish_recipe.html', user=session["user"], dishes=dishes)


@app.route('/get_dish_raw_materials', methods=['GET'])
def get_dish_raw_materials():
    dish_id = int(request.args.get('dish_id'))
    materials_map = get_dish_recipe_raw_materials(dish_id)
    return jsonify({'raw_materials': materials_map})


@app.route('/submit_raw_materials', methods=['POST'])
def submit_raw_materials():
    data = request.get_json()
    app.logger.debug(f"Received data: {data}")

    dish_id = data["dish_id"]
    incoming_materials = data["materials"]

    # Fetch current materials from the database
    current_materials = get_dish_recipe_raw_materials(dish_id)
    app.logger.debug(f"Current materials: {current_materials}")

    # Map current materials for easy comparison
    current_map = {mat[1].lower(): (mat[2], mat[3]) for mat in current_materials}  # {name: (quantity, metric)}
    incoming_map = {mat["name"].lower(): (float(mat["quantity"]), mat["metric"]) for mat in incoming_materials}

    to_update = []
    to_insert = []
    to_delete = []

    # Identify materials to update or insert
    for name, (quantity, metric) in incoming_map.items():
        if name in current_map:
            # Check if there is a difference
            if current_map[name] != (quantity, metric):
                to_update.append((dish_id, name, quantity, metric))
        else:
            # New material to insert
            to_insert.append((dish_id, name, quantity, metric))

    # Identify materials to delete
    for name in current_map:
        if name not in incoming_map:
            to_delete.append(name)

    # Perform batch updates, inserts, and deletions
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        # Update materials
        for dish_id, name, quantity, metric in to_update:
            cursor.execute("""
                UPDATE dish_raw_materials AS drm
                JOIN raw_materials AS rm ON drm.raw_material_id = rm.id
                SET drm.quantity = %s, drm.metric = %s
                WHERE drm.dish_id = %s AND rm.name = %s
            """, (quantity, metric, dish_id, name))

        # Insert new materials
        for dish_id, name, quantity, metric in to_insert:
            # Check if the raw material already exists
            cursor.execute("SELECT id FROM raw_materials WHERE name = %s", (name,))
            raw_material = cursor.fetchone()

            if raw_material:
                raw_material_id = raw_material[0]
            else:
                # Insert raw material if not exists
                cursor.execute("INSERT INTO raw_materials (name, metric) VALUES (%s, %s)", (name, metric))
                raw_material_id = cursor.lastrowid

            # Insert into dish_raw_materials
            cursor.execute("""
                INSERT INTO dish_raw_materials (dish_id, raw_material_id, quantity, metric)
                VALUES (%s, %s, %s, %s)
            """, (dish_id, raw_material_id, quantity, metric))

        # Delete removed materials
        for name in to_delete:
            cursor.execute("""
                DELETE drm FROM dish_raw_materials AS drm
                JOIN raw_materials AS rm ON drm.raw_material_id = rm.id
                WHERE drm.dish_id = %s AND rm.name = %s
            """, (dish_id, name))

        conn.commit()
        flash('Raw materials updated successfully', "success")
        return jsonify({
            'message': 'Raw materials updated successfully.',
            'redirect_url': url_for("edit_dish_recipe")  # Include the redirect URL
        }), 200
    except Exception as e:
        conn.rollback()
        app.logger.error(f"Error updating raw materials: {e}")
        flash(f"Error updating raw materials: {e}", "danger")
        return redirect(url_for("edit_dish_recipe"))
    finally:
        cursor.close()
        conn.close()


@app.route("/edit_dish_recipe", methods=['GET', 'POST'])
def edit_dish_recipe():
    if "user" not in session:
        return redirect("/login")
    dish_categories = get_unique_dish_categories()
    app.logger.debug(dish_categories)
    dishes = get_all_dishes()
    app.logger.debug(dishes)
    return render_template('edit_dish_recipe.html', user=session["user"], dish_categories=dish_categories, dishes=dishes)


@app.route('/add_vendor', methods=['GET', 'POST'])
def add_vendor():
    if "user" not in session:
        return redirect("/login")

    if request.method == "POST":
        vendor_names = request.form.getlist("vendor_name[]")
        phone_numbers = request.form.getlist("phone_number[]")
        addresses = request.form.getlist("address[]")
        app.logger.debug(f"vendor_names {vendor_names}")
        app.logger.debug(f"phone_numbers {phone_numbers}")
        app.logger.debug(f"addresses {addresses}")
        if vendor_names and phone_numbers and addresses:
            app.logger.debug("if")
            try:
                db_connection = get_db_connection()
                cursor = db_connection.cursor()

                # Insert each vendor's data into the database
                for name, phone, address in zip(vendor_names, phone_numbers, addresses):
                    cursor.execute(
                        "INSERT INTO vendor_list (vendor_name, phone, address) VALUES (%s, %s, %s)",
                        (name, phone, address)
                    )

                db_connection.commit()
                cursor.close()
                db_connection.close()
                flash('Vendor added successfully!', 'success')
            except Exception as e:
                app.logger.error(f"Error: {e}")
                flash("An error occurred while adding vendor details.", 'danger')
            return redirect("/add_vendor")
    return render_template('add_vendor.html', user=session["user"])


@app.route("/list_vendors", methods=["GET", "POST"])
def list_vendors():
    if "user" not in session:
        return redirect("/login")
    vendors = get_all_vendors()
    return render_template("list_vendors.html", user=session["user"], vendors=vendors)


@app.route('/add_purchase', methods=['GET', 'POST'])
def add_purchase():
    if "user" not in session:
        return redirect("/login")

    connection = get_db_connection()
    raw_materials = get_all_rawmaterials()
    storage_rooms = get_all_storagerooms(only_active=True)
    vendors = get_all_vendors(only_active=True)

    if request.method == 'POST':
        app.logger.debug(f"request {request.form}")

        # Retrieve form data
        vendor_name = request.form.get('vendor')
        storageroom_name = request.form.get('storage_room')
        raw_material_names = request.form.getlist('raw_material[]')
        quantities = request.form.getlist('quantity[]')
        metrics = request.form.getlist('metric[]')
        total_costs = request.form.getlist('total_cost[]')
        purchase_date = request.form.get("purchase_date")
        invoice_number = request.form.get("invoice_number")

        # Validate vendor
        vendor = next((v for v in vendors if v['vendor_name'] == vendor_name), None)
        if not vendor:
            flash('Vendor does not exist. Please add the vendor first.', 'danger')
            return redirect('/add_purchase')

        # Validate storage room
        storageroom = next((s for s in storage_rooms if s['storageroomname'] == storageroom_name), None)
        if not storageroom:
            flash('Storage room does not exist. Please add the storage room first.', 'danger')
            return redirect('/add_purchase')

        # Create a cursor for database operations
        cursor = connection.cursor()

        # Process each raw material in the form
        for raw_material_name, quantity, metric, cost in zip(raw_material_names, quantities, metrics, total_costs):
            # Check and add raw material if not exists
            raw_material = next((rm for rm in raw_materials if rm['name'] == raw_material_name), None)
            app.logger.debug(f"raw raw {raw_material}")
            if not raw_material:
                cursor.execute(
                    "INSERT INTO raw_materials (name, metric) VALUES (%s, %s)",
                    (raw_material_name, metric)
                )
                connection.commit()
                raw_material_id = cursor.lastrowid
            else:
                raw_material_id = raw_material['id']

            # Perform metric conversion
            quantity, metric = convert_metric(quantity, metric)

            # Insert or update purchase history
            cursor.execute(
                """
                INSERT INTO purchase_history
                (vendor_id, invoice_number, raw_material_id, raw_material_name,
                 quantity, metric, total_cost, purchase_date, storageroom_id)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE
                    quantity = quantity + VALUES(quantity),
                    total_cost = total_cost + VALUES(total_cost);
                """,
                (vendor["id"], invoice_number, raw_material_id, raw_material_name,
                 quantity, metric, cost, purchase_date, storageroom['id'])
            )
            app.logger.debug(f"purchase_history_done")

            # Update vendor payment tracker
            cursor.execute(
                """
                INSERT INTO vendor_payment_tracker (vendor_id, invoice_number, outstanding_cost)
                VALUES (%s, %s, %s)
                ON DUPLICATE KEY UPDATE outstanding_cost = outstanding_cost + VALUES(outstanding_cost);
                """,
                (vendor['id'], invoice_number, cost)
            )
            app.logger.debug(f"vendor_payment_tracker_done")
            # Update storage room stock
            cursor.execute(
                """
                INSERT INTO storageroom_stock (storageroom_id, raw_material_id, quantity, metric)
                VALUES (%s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE
                    quantity = quantity + VALUES(quantity),
                    metric = VALUES(metric);
                """,
                (storageroom['id'], raw_material_id, quantity, metric)
            )
            app.logger.debug(f"storageroom_stock_done")

        # Commit all changes and close the cursor
        connection.commit()
        cursor.close()
        connection.close()

        flash('Purchases added successfully!', 'success')
        return redirect('/add_purchase')

    return render_template(
        'add_purchase.html',
        vendors=vendors,
        raw_materials=raw_materials,
        storage_rooms=storage_rooms,
        user=session["user"],
        today_date=get_current_date()
    )


def convert_metric(quantity, metric):
    """
    Convert quantity to base metric (kilograms or liters) if needed.
    """
    quantity = float(quantity)
    if metric == 'grams':
        quantity /= 1000  # Convert grams to kilograms
        metric = 'kg'
    elif metric == 'ml':
        quantity /= 1000  # Convert milliliters to liters
        metric = 'liter'
    return quantity, metric


@app.route('/get_ledger_statement', methods=['POST'])
def get_ledger_statement():
    connection = get_db_connection()
    cursor = connection.cursor()
    vendor_id = request.json.get("vendorId")
    from_date = request.json.get("fromDate")
    to_date = request.json.get("toDate")
    # cursor.execute("SELECT DISTINCT invoice_number FROM purchase_history WHERE vendor_id = %s", (vendor_id,))
    # invoices = [{"invoice_number": row[0]} for row in cursor.fetchall()]
    # cursor.close()
    # connection.close()
    # app.logger.debug(f"hey {invoices}")
    app.logger.debug(f"hey {vendor_id}")
    app.logger.debug(f"hey {from_date}")
    app.logger.debug(f"hey {to_date}")
    invoices = [
        {"date": "19-June-2024", "type": "Purchase Bill", "sr_no": 17,
         "payment_mode": "-", "credit": 22819.93, "debit": 0.0, "balance": -22819.93},
        {"date": "02-July-2024", "type": "Payment-out", "sr_no": 11,
         "payment_mode": "Online", "credit": 22819.93, "debit": 0.0, "balance": 0.0},
        {"date": "05-August-2024", "type": "Purchase Bill", "sr_no": 27,
         "payment_mode": "-", "credit": 6465.66, "debit": 0.0, "balance": -6465.66},
        {"date": "10-August-2024", "type": "Payment-out", "sr_no": 19,
         "payment_mode": "Online", "credit": 6465.66, "debit": 0.0, "balance": 0.0},
        {"date": "26-December-2024", "type": "Purchase Bill", "sr_no": 49,
         "payment_mode": "Cash", "credit": 40853.37, "debit": 25000.0, "balance": -15853.37},
        {"date": "09-January-2025", "type": "Payment-out", "sr_no": 37,
         "payment_mode": "Bank", "credit": 15853.37, "debit": 0.0, "balance": 0.0}
    ]
    return jsonify(invoices)


@app.route('/get_purchases/<invoice_number>', methods=['GET'])
def get_purchases(invoice_number):
    connection = get_db_connection()
    cursor = connection.cursor()
    cursor.execute("""
        SELECT ph.id, ph.invoice_number, v.vendor_name, ph.raw_material_name, ph.quantity, ph.metric,
               ph.total_cost, ph.purchase_date, sr.storageroomname
        FROM purchase_history ph
        JOIN vendor_list v ON ph.vendor_id = v.id
        JOIN storagerooms sr ON ph.storageroom_id = sr.id
        WHERE ph.invoice_number = %s
    """, (invoice_number,))
    purchases = [
        {
            "id": row[0],
            "invoice_number": row[1],
            "vendor_name": row[2],
            "raw_material_name": row[3],
            "quantity": row[4],
            "metric": row[5],
            "total_cost": row[6],
            "purchase_date": datetime.strptime(str(row[7]), '%Y-%m-%d').strftime('%A, %d %B %Y'),
            "storageroom_name": row[8]
        }
        for row in cursor.fetchall()
    ]

    total_amount = sum(purchase["total_cost"] for purchase in purchases)
    app.logger.debug(f"pur {purchases}")
    cursor.close()
    connection.close()
    return jsonify({"purchases": purchases, "total_amount": total_amount})


@app.route('/purchase_list')
def purchase_list():
    if "user" not in session:
        return redirect("/login")
    # purchases = get_all_purchases()
    vendors = get_all_vendors(only_active=True)
    return render_template('purchase_list.html', vendors=vendors, user=session["user"])


@app.route('/purchase_record')
def purchase_record():
    if "user" not in session:
        return redirect("/login")
    # purchases = get_all_purchases()
    today_date = get_current_date()
    vendors = get_all_vendors(only_active=True)
    owner = {"name": "Dharani Groups", "phone_num": "123456789", "address": "No 123, Tirunelveli"}
    return render_template('purchase_record.html', user=session["user"], owner=owner, vendors=vendors, today_date=today_date)


@app.route("/get_purchase_transaction", methods=["GET"])
def get_purchase_transaction():
    date = request.args.get("date")
    app.logger.debug(f"date {date}")
    transactions, total_purchase_amount = get_purchase_record(date=date)
    app.logger.debug({"purchases": transactions, "total_amount": total_purchase_amount})
    return jsonify({"purchases": transactions, "total_amount": total_purchase_amount})


@app.route("/get_purchase_records", methods=["GET"])
def fetch_purchase_records():
    vendor_id = request.args.get("vendor_id", "all")
    from_date = request.args.get("from_date")
    to_date = request.args.get("to_date")

    if not from_date or not to_date:
        return jsonify({"error": "Invalid date range"}), 400

    try:
        datetime.strptime(from_date, "%Y-%m-%d")
        datetime.strptime(to_date, "%Y-%m-%d")
    except ValueError:
        return jsonify({"error": "Invalid date format"}), 400

    purchases, vendor_totals = get_purchase_records(vendor_id, from_date, to_date)
    # app.logger.debug({
    #     "purchases": purchases,
    #     "vendor_totals": vendor_totals
    # })

    return jsonify({
        "purchases": purchases,
        "vendor_totals": vendor_totals
    })


@app.route("/get_payment_records", methods=["GET"])
def fetch_payment_records():
    vendor_id = request.args.get("vendor_id", "all")
    from_date = request.args.get("from_date")
    to_date = request.args.get("to_date")

    if not from_date or not to_date:
        return jsonify({"error": "Invalid date range"}), 400

    try:
        datetime.strptime(from_date, "%Y-%m-%d")
        datetime.strptime(to_date, "%Y-%m-%d")
    except ValueError:
        return jsonify({"error": "Invalid date format"}), 400

    payments, vendor_totals = get_payment_records(vendor_id, from_date, to_date)

    return jsonify({"payments": payments, "vendor_totals": vendor_totals})


@app.route("/get_pending_payments_record", methods=["GET"])
def fetch_pending_payments_record():
    vendor_id = request.args.get("vendor_id", "all")
    app.logger.debug(f"get_pending_payments_record {vendor_id}")
    # from_date = request.args.get("from_date")
    # to_date = request.args.get("to_date")

    # if not from_date or not to_date:
    #     return jsonify({"error": "Invalid date range"}), 400

    # try:
    #     datetime.strptime(from_date, "%Y-%m-%d")
    #     datetime.strptime(to_date, "%Y-%m-%d")
    # except ValueError:
    #     return jsonify({"error": "Invalid date format"}), 400

    pending_payments, vendor_totals = get_pending_payments_record(vendor_id)
    app.logger.debug(f"get_pending_payments_record {pending_payments}")
    app.logger.debug(f"get_pending_payments_record {vendor_totals}")

    return jsonify({"payments": pending_payments, "vendor_totals": vendor_totals})


@app.route("/get_payment_transaction", methods=["GET"])
def get_payment_transaction():
    date = request.args.get("date")
    app.logger.debug(f"date {date}")
    transactions, total_paid_amount = get_payment_record_on_date(date=date)
    app.logger.debug({"payments": transactions, "total_amount": total_paid_amount})
    return jsonify({"payments": transactions, "total_amount": total_paid_amount})


@app.route("/pay_vendor", methods=["GET", "POST"])
def pay_vendor():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        # Handle form submission
        vendor_id = request.json.get("vendorId")
        vendor_name = request.json.get("vendorName")
        amount_paid = float(request.json.get("amountPaid"))
        app.logger.debug(f"vendor_id {vendor_id}")
        app.logger.debug(f"vendor_name {vendor_name}")
        app.logger.debug(f"amount_paid {amount_paid}")
        connection = get_db_connection()
        cursor = connection.cursor()
        cursor.execute(
            """
                INSERT INTO vendor_payment_tracker (vendor_id, total_paid)
                VALUES (%s, %s)
                ON DUPLICATE KEY UPDATE total_paid = total_paid + %s
                """,
            (vendor_id, amount_paid, amount_paid)
        )
        connection.commit()
        cursor.close()
        connection.close()
        flash('Payment done successfully!', "success")
        return redirect(url_for("pending_payments"))
    pending_payments_vendor_cumulative = get_all_pending_payments_vendor_cumulative()
    return render_template("pay_vendor.html", user=session["user"], pending_payments_vendor_cumulative=pending_payments_vendor_cumulative, todays_date=get_current_date())


@app.route("/pending_payments", methods=["GET", "POST"])
def pending_payments():
    if "user" not in session:
        return redirect("/login")
    today_date = get_current_date()
    vendors = get_all_vendors(only_active=True)
    owner = {"name": "Dharani Groups", "phone_num": "123456789", "address": "No 123, Tirunelveli"}
    return render_template('pending_payments.html', user=session["user"], owner=owner, vendors=vendors, today_date=today_date)


@app.route("/process_payments", methods=["POST"])
def process_payments():
    # try:
    if request.method == "POST":
        app.logger.debug(f"process_payments {request.json}")
        vendor_id = request.json.get("vendor_id")
        paid_values = []
        for payment in request.json.get("payments", []):
            if payment["pay_amount"] > 0:
                paid_values.append(payment)
        app.logger.debug(f"vendor id {vendor_id}")
        app.logger.debug(f"paid values {paid_values}")
        connection = get_db_connection()
        cursor = connection.cursor()
        for payment_detail in paid_values:
            app.logger.debug(payment_detail)
            cursor.execute(
                """
                    INSERT INTO vendor_payment_tracker (vendor_id, invoice_number, total_paid) 
                    VALUES (%s, %s, %s) 
                    ON DUPLICATE KEY UPDATE total_paid = total_paid + %s
                    """,
                (vendor_id, payment_detail["invoice_number"],
                    payment_detail["pay_amount"], payment_detail["pay_amount"])
            )
            cursor.execute(
                """
                    INSERT INTO payment_records (vendor_id, invoice_number, amount_paid, mode_of_payment, paid_on) 
                    VALUES (%s, %s, %s, %s, %s) 
                    """,
                (vendor_id, payment_detail["invoice_number"],
                    payment_detail["pay_amount"], payment_detail["mode_of_payment"], payment_detail["date_of_payment"])
            )
        connection.commit()
        cursor.close()
        connection.close()
        flash('Payment processed successfully!', 'success')
        return jsonify({'message': 'Payment processed successfully'}), 200
    # except Exception as e:
    #     flash(f'An error occurred while processing the payment. Please try again. {str(e)}', 'error')
    #     return jsonify({'error': str(e)}), 400


@app.route('/storageroom_stock')
def storageroom_stock():
    if "user" not in session:
        return redirect("/login")
    storage_stock = get_storageroom_stock()

    return render_template('storageroom_stock.html', storage_stock=storage_stock, user=session["user"])


@app.route('/kitchen_inventory_stock')
def kitchen_inventory_stock():
    if "user" not in session:
        return redirect("/login")
    kitcheninv_stock = get_kitchen_inventory_stock()

    return render_template('kitchen_inventory_stock.html', kitcheninv_stock=kitcheninv_stock, user=session["user"])


@app.route('/get_vendor_payments', methods=["GET"])
def get_vendor_payments():
    vendor_id = request.args.get('vendor_id')
    from_date = request.args.get('from_date')
    to_date = request.args.get('to_date')

    app.logger.debug(f"Vendor ID: {vendor_id}, From Date: {from_date}, To Date: {to_date}")

    # Convert string dates to datetime objects
    try:
        from_date = datetime.strptime(from_date, '%Y-%m-%d')
        to_date = datetime.strptime(to_date, '%Y-%m-%d')
    except ValueError:
        return jsonify({"error": "Invalid date format"}), 400

    # Fetch payment records for the given vendor and date range
    payments_per_vendor = get_payment_details_of_vendor_between_dates(vendor_id, from_date, to_date)
    app.logger.debug(f"payments_per_vendor {payments_per_vendor}")

    def serialize(payment):
        return {
            'paid_on': payment['paid_on'].strftime('%Y-%m-%d'),
            'invoice_number': payment['invoice_number'],
            'mode_of_payment': payment['mode_of_payment'],
            'amount_paid': float(payment['amount_paid'])
        }

    return jsonify({'payments': [serialize(p) for p in payments_per_vendor]})


@app.route("/get_payment_details/<vendor_id>", methods=["GET"])
def get_payment_details(vendor_id):
    # vendor_id = request.args.get('vendor_id')
    app.logger.debug(f"modal vendor_id input {vendor_id}")
    payments_per_vendor = get_payment_details_of_vendor(vendor_id)
    app.logger.debug(f"payments_per_vendor {payments_per_vendor}")

    def serialize(payment):
        return {
            'payment_id': payment['payment_id'],
            'invoice_number': payment['invoice_number'],
            'purchase_date': payment['purchase_date'],
            'outstanding_cost': float(payment['outstanding_cost']),
            'total_paid': float(payment['total_paid']),
            'total_due': float(payment['total_due']),
            'last_updated': payment['last_updated'].strftime('%Y-%m-%d %H:%M:%S')
        }

    return jsonify([serialize(p) for p in payments_per_vendor])


@app.route("/payment_receipt")
def payment_receipt():
    if "user" not in session:
        return redirect("/login")
    inv_payment_details = get_invoice_payment_details()
    vendors = get_all_vendors(only_active=True)
    owner = {"name": "Dharani Groups", "phone_num": "123456789", "address": "No 123, Tirunelveli"}
    return render_template('payment_receipt.html', vendors=vendors, owner=owner, inv_payment_details=inv_payment_details, user=session["user"])


@app.route("/payment_record")
def payment_record():
    if "user" not in session:
        return redirect("/login")
    # payment_record = get_payment_record()
    today_date = get_current_date()
    vendors = get_all_vendors(only_active=True)
    owner = {"name": "Dharani Groups", "phone_num": "123456789", "address": "No 123, Tirunelveli"}
    return render_template('payment_record.html', user=session["user"], vendors=vendors, owner=owner, today_date=today_date)


@app.route('/restaurant_inventory_stock')
def restaurant_inventory_stock():
    if "user" not in session:
        return redirect("/login")
    restaurantinv_stock = get_restaurant_inventory_stock()

    return render_template('restaurant_inventory_stock.html', restaurantinv_stock=restaurantinv_stock, user=session["user"])


# Utility function for converting metric units

def convert_to_base_units(quantity, metric):
    if metric == "grams":
        return quantity / 1000  # Convert grams to kg
    elif metric == "ml":
        return quantity / 1000  # Convert ml to liters
    return quantity  # Return as is for kg, liters, and units


@app.route('/transfer_raw_material', methods=['GET', 'POST'])
def transfer_raw_material():
    if "user" not in session:
        return redirect("/login")

    if request.method == 'POST':
        source_storageroom_id = request.form.get("storageroom")
        destination_type = request.form.get("destination_type")
        destination_id = request.form.get("destination_name")
        transfer_date = request.form.get("transfer_date")

        raw_materials = request.form.getlist("raw_material_id[]")
        quantities = request.form.getlist("quantity[]")
        metrics = request.form.getlist("metric[]")

        transfer_details = []
        for raw_material, quantity, metric in zip(raw_materials, quantities, metrics):
            raw_material_data = get_raw_material_by_id(raw_material)
            if not raw_material_data:
                flash(f"Raw material {raw_material} is not available. Please add it first.", "danger")
                return redirect(url_for("transfer_raw_material"))

            converted_quantity = convert_to_base_units(quantity, metric)
            transfer_details.append({
                "raw_material_id": raw_material,
                "raw_material_name": raw_material_data["name"],
                "quantity": converted_quantity,
                "metric": metric,
            })

        try:
            destination_table = {
                'kitchen': 'kitchen_inventory_stock',
                'restaurant': 'restaurant_inventory_stock'
            }.get(destination_type)

            if not destination_table:
                flash('Invalid destination type', 'danger')
                return redirect('/transfer_raw_material')

            for detail in transfer_details:
                raw_material_id = detail["raw_material_id"]
                quantity = detail["quantity"]
                metric = detail["metric"]

                # Deduct from source storeroom
                execute_query(
                    "UPDATE storageroom_stock SET quantity = quantity - %s WHERE storageroom_id = %s AND raw_material_id = %s",
                    (quantity, source_storageroom_id, raw_material_id)
                )

                # Update or insert into destination table
                destination_stock = get_data(
                    f"SELECT quantity FROM {destination_table} WHERE {destination_type}_id = %s AND raw_material_id = %s",
                    (destination_id, raw_material_id)
                )

                if destination_stock:
                    execute_query(
                        f"UPDATE {destination_table} SET quantity = quantity + %s WHERE {destination_type}_id = %s AND raw_material_id = %s",
                        (quantity, destination_id, raw_material_id)
                    )
                else:
                    execute_query(
                        f"INSERT INTO {destination_table} ({destination_type}_id, raw_material_id, quantity, metric) VALUES (%s, %s, %s, %s)",
                        (destination_id, raw_material_id, quantity, metric)
                    )

                # Log the transfer
                execute_query(
                    """INSERT INTO raw_material_transfer_details 
                        (source_storage_room_id, destination_type, destination_id, raw_material_id, quantity, metric, transferred_date)
                        VALUES (%s, %s, %s, %s, %s, %s, %s)
                        ON DUPLICATE KEY UPDATE quantity = quantity + VALUES(quantity)""",
                    (source_storageroom_id, destination_type, destination_id,
                     raw_material_id, quantity, metric, transfer_date)
                )

            flash('Transfer successful', 'success')
        except Exception as e:
            flash(f"An error occurred: {e}", 'danger')

        return redirect('/transfer_raw_material')

    # GET request - Load necessary data
    return render_template(
        'transfer_raw_material.html',
        raw_materials=get_all_rawmaterials(),
        storage_rooms=get_all_storagerooms(only_active=True),
        restaurants=get_all_restaurants(only_active=True),
        kitchens=get_all_kitchens(only_active=True),
        storageroom_stock=get_storageroom_stock(),
        user=session["user"],
        today_date=get_current_date()
    )


@app.route('/list_rawmaterial_transfers', methods=["GET", "POST"])
def list_rawmaterial_transfers():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        selected_date = request.form['transfer_date']
        transfers = get_rawmaterial_transfer_history(selected_date)
        return render_template('list_rawmaterial_transfers.html', transfers=transfers, current_date=selected_date, user=session["user"])
    return render_template('list_rawmaterial_transfers.html', user=session["user"])


@app.route('/list_prepared_dishes_transfers', methods=["GET", "POST"])
def list_prepared_dishes_transfers():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        selected_date = request.form['transfer_date']
        transfers = get_prepared_dishes_transfer_history(selected_date)
        return render_template('list_prepared_dishes_transfers.html', transfers=transfers, current_date=selected_date, user=session["user"])
    return render_template('list_prepared_dishes_transfers.html', user=session["user"])


@app.route('/profile', methods=['GET', 'POST'])
def profile():
    if "user" not in session:
        return redirect("/login")
    user = get_user_by_email(session["user"]["email"])
    app.logger.debug(user)
    return render_template('profile.html', user=user)


@app.route('/logout')
def logout():
    if "user" not in session:
        return redirect("/login")
    session.pop("user")
    return redirect("/login")


# @app.route('/bulk_add_purchases', methods=['GET', 'POST'])
# def bulk_add_purchases():
#     try:
#         conn = get_db_connection()
#         with conn.cursor() as cursor:
#             # Fetch inventory
#             cursor.execute("SELECT id, inventoryname, inventorycode FROM inventory")
#             inventories = cursor.fetchall()

#         if request.method == 'POST':
#             app.logger.debug(f"Request data: {request.data}")
#             app.logger.debug(f"Form keys: {list(request.form.keys())}")

#             inventory_id = request.form.get('inventory_id')
#             if not inventory_id:
#                 flash('Inventory selection is required.', 'danger')
#                 return redirect(url_for('bulk_add_purchases'))

#             inventory_name = get_inventory_by_id(inventory_id).get("inventoryname", "Unknown Inventory")
#             raw_material_data = []

#             for key, value in request.form.items():
#                 if key.startswith('material_'):
#                     raw_material_id = key.split('_')[1]
#                     raw_material_name = value
#                     try:
#                         quantity = float(request.form[f'quantity_{raw_material_id}'])
#                         metric = request.form[f'metric_{raw_material_id}']
#                         total_cost = float(request.form[f'total_cost_{raw_material_id}'])
#                         purchase_date = request.form[f'purchase_date_{raw_material_id}']
#                         raw_material_data.append((raw_material_id, raw_material_name,
#                                                  quantity, metric, total_cost, purchase_date))
#                     except KeyError as e:
#                         flash(f'Missing data for raw material {raw_material_name}: {str(e)}', 'danger')
#                         return redirect(url_for('bulk_add_purchases'))

#             with conn.cursor() as cursor:
#                 for raw_material in raw_material_data:
#                     raw_material_id, raw_material_name, quantity, metric, total_cost, purchase_date = raw_material
#                     # Insert or update purchase history
#                     cursor.execute("""
#                         INSERT INTO purchase_history
#                         (raw_material_id, raw_material_name, quantity, metric, total_cost, purchase_date, inventory_id)
#                         VALUES (%s, %s, %s, %s, %s, %s, %s)
#                     """, (raw_material_id, raw_material_name, quantity, metric, total_cost, purchase_date, inventory_id))

#                     # Update inventory stock
#                     cursor.execute("""
#                         INSERT INTO inventory_stock
#                         (inventory_id, inventory_name, raw_material_id, raw_material_name, quantity, metric)
#                         VALUES (%s, %s, %s, %s, %s, %s)
#                         ON DUPLICATE KEY UPDATE
#                         quantity = quantity + VALUES(quantity),
#                         metric = VALUES(metric),
#                         inventory_name = VALUES(inventory_name),
#                         raw_material_name = VALUES(raw_material_name)
#                     """, (inventory_id, inventory_name, raw_material_id, raw_material_name, quantity, metric))
#                 conn.commit()

#             flash('Bulk purchase data submitted successfully!', 'success')
#             return redirect(url_for('bulk_add_purchases'))

#         # Fetch raw materials and last purchase details
#         with conn.cursor() as cursor:
#             cursor.execute("""
#                 SELECT r.id, r.name, r.metric,
#                        COALESCE(p.quantity, NULL) AS last_quantity,
#                        COALESCE(p.metric, NULL) AS last_metric,
#                        COALESCE(p.total_cost, NULL) AS last_cost,
#                        COALESCE(p.purchase_date, NULL) AS last_date
#                 FROM raw_materials r
#                 LEFT JOIN (
#                     SELECT raw_material_id, quantity, metric, total_cost, purchase_date
#                     FROM purchase_history
#                     WHERE purchase_date = (SELECT MAX(purchase_date)
#                                            FROM purchase_history
#                                            WHERE raw_material_id = purchase_history.raw_material_id)
#                 ) p ON r.id = p.raw_material_id
#             """)
#             raw_materials = cursor.fetchall()

#         # Deduplicate raw materials
#         columns = ['id', 'name', 'metric', 'last_quantity', 'last_metric', 'last_cost', 'last_date']
#         raw_materials = [dict(zip(columns, row)) for row in raw_materials]
#         unique_raw_materials = {material['id']: material for material in raw_materials}
#         raw_materials = list(unique_raw_materials.values())

#         return render_template('bulk_add_purchases.html', user=session["user"], raw_materials=raw_materials, current_date=get_current_date(), inventories=inventories)

#     except Exception as e:
#         app.logger.error(f"An error occurred: {e}")
#         flash('An unexpected error occurred. Please try again.', 'danger')
#         return redirect(url_for('bulk_add_purchases'))


def convert_to_base_unit(quantity, metric):
    """Converts the given quantity to its base unit (grams or ml)."""
    conversions = {
        'kg': 1000,
        'grams': 1,
        'liter': 1000,
        'ml': 1,
        'unit': 1
    }
    return quantity * conversions.get(metric, 1)


def convert_to_original_unit(quantity, metric):
    """Converts the given quantity to its original unit (grams or ml)."""
    conversions = {
        'kg': 1000,
        'grams': 1,
        'liter': 1000,
        'ml': 1,
        'unit': 1
    }
    return quantity // conversions.get(metric, 1)


@app.route('/estimate_dishes', methods=['GET', 'POST'])
def estimate_dishes():
    estimates_data = []
    if request.method == "POST":
        selected_date = request.form.get('date')
        # selected_date = '2024-12-29'

        if not selected_date:
            return jsonify({"error": "Please provide a valid date."}), 400

        try:
            connection = get_db_connection()
            with connection.cursor() as cursor:
                # Query transferred raw materials on the selected date
                transfer_query = """
                    SELECT raw_material_id, raw_material_name, SUM(quantity) as total_quantity, metric
                    FROM raw_material_transfer
                    WHERE transaction_date = %s
                    GROUP BY raw_material_id, raw_material_name, metric
                """
                cursor.execute(transfer_query, (selected_date,))
                transferred_materials = cursor.fetchall()
                app.logger.debug(f"transferred_materials {transferred_materials}")

                if not transferred_materials:
                    return jsonify({"message": "No data available for the selected date."})

                # Convert transferred materials to a dictionary
                material_map = {}
                for material in transferred_materials:
                    material_map[material[0]] = {
                        'name': material[1],
                        'quantity': convert_to_base_unit(material[2], material[3]),
                        'metric': material[3]
                    }
                app.logger.debug(f"material_map {material_map}")

                # Query all dishes and their required raw materials
                dishes_query = """
                    SELECT d.id AS dish_id, d.name AS dish_name, drm.raw_material_id, drm.quantity, drm.metric
                    FROM dishes d
                    JOIN dish_raw_materials drm ON d.id = drm.dish_id
                """
                cursor.execute(dishes_query)
                dish_data = cursor.fetchall()
                app.logger.debug(f"dish_data {dish_data}")
                # Calculate estimates for each dish
                dish_estimates = {}

                for dish in dish_data:
                    dish_id = dish[0]
                    dish_name = dish[1]
                    raw_material_id = dish[2]

                    # Skip if raw material is not available in the transferred data
                    if raw_material_id not in material_map:
                        continue

                    # Convert required raw material quantity to base unit
                    required_quantity = convert_to_base_unit(dish[3], dish[4])

                    # Calculate max dishes that can be prepared with available material
                    available_quantity = material_map[raw_material_id]['quantity']
                    max_dishes = float(available_quantity) // float(required_quantity)
                    app.logger.debug(f" dish {dish}, max_dishes {max_dishes}")

                    if dish_id not in dish_estimates:
                        dish_estimates[dish_id] = {
                            'name': dish_name,
                            'raw_materials': [],
                            'estimate': max_dishes
                        }
                    else:
                        dish_estimates[dish_id]['estimate'] = min(dish_estimates[dish_id]['estimate'], max_dishes)

                    # Add raw material details
                    dish_estimates[dish_id]['raw_materials'].append({
                        'name': material_map[raw_material_id]['name'],
                        'quantity_used': convert_to_original_unit(available_quantity, material_map[raw_material_id]['metric']),
                        'metric': material_map[raw_material_id]['metric']
                    })

                # Prepare the estimates_data
                estimates_data = []
                for dish_id, details in dish_estimates.items():
                    estimates_data.append({
                        'dish_name': details['name'],
                        'raw_materials': details['raw_materials'],
                        'estimate': details['estimate']
                    })

                return render_template("estimate_dishes.html", user=session["user"], estimates=estimates_data, selected_date=None)

        except Exception as e:
            return jsonify({"error": str(e)}), 500

        finally:
            connection.close()
    return render_template("estimate_dishes.html", user=session["user"], estimates=estimates_data, selected_date=None)


# @app.route('/bulk_transfer', methods=['GET', 'POST'])
# def bulk_transfer():
#     if request.method == 'GET':
#         # Query the list of available dishes for selection (if applicable)
#         dishes_query = "SELECT id, name FROM dishes"
#         dishes = execute_query(dishes_query)

#         return render_template('bulk_raw_material_transfer.html', dishes=dishes)

#     elif request.method == 'POST':
#         try:
#             # Get form data
#             inventory_id = request.form.get('inventory_id')
#             dish_id = request.form.get('dish_id')
#             transfer_data = {
#                 key: value
#                 for key, value in request.form.items()
#                 if key.startswith("transfer_quantity_")
#             }

#             # Process each raw material transfer
#             for raw_material_id, transfer_quantity in transfer_data.items():
#                 raw_material_id = raw_material_id.replace("transfer_quantity_", "")
#                 transfer_quantity = float(transfer_quantity)

#                 # Validate available quantity
#                 query = """
#                     SELECT quantity
#                     FROM inventory_stock
#                     WHERE raw_material_id = %s AND inventory_id = %s
#                 """
#                 available_quantity = execute_query(query, (raw_material_id, inventory_id))[0][0]

#                 if transfer_quantity > available_quantity:
#                     flash(f"Transfer quantity for raw material {raw_material_id} exceeds available quantity.", "danger")
#                     return redirect('/bulk_transfer')

#                 # Update inventory
#                 update_query = """
#                     UPDATE inventory_stock
#                     SET quantity = quantity - %s
#                     WHERE raw_material_id = %s AND inventory_id = %s
#                 """
#                 execute_query(update_query, (transfer_quantity, raw_material_id, inventory_id))

#             flash("Bulk transfer completed successfully.", "success")
#             return redirect('/bulk_transfer')

#         except Exception as e:
#             flash(f"An error occurred: {e}", "danger")
#             return redirect('/bulk_transfer')


@app.route('/upload_sales_report', methods=['GET', 'POST'])
def upload_sales_report():
    if "user" not in session:
        return redirect("/login")

    if request.method == 'POST':
        app.logger.debug(f"request.files {request.files}")
        file = request.files.get('file')
        restaurant_id = request.form.get("restaurant_id")
        sales_date = request.form.get("sales_report_date")
        app.logger.debug(f"restaurant_id {restaurant_id}")
        app.logger.debug(f"sales_date {sales_date}")

        if 'file' not in request.files:
            flash('No file part found. Please try again.', "danger")
            return redirect(url_for('upload_sales_report'))

        if file.filename == '':
            flash('No selected file. Please upload a file', "danger")
            return redirect(url_for('upload_sales_report'))

        if file and file.filename.endswith('.xlsx'):
            # Save the file
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
            file.save(file_path)

            # Process the file
            missing_recipes = process_data(file_path)

            if missing_recipes:
                missing_recipes_table = """
                    <table class="table table-bordered">
                        <thead>
                            <tr>
                                <th>Missing Recipe</th>
                            </tr>
                        </thead>
                        <tbody>
                """
                for recipe in missing_recipes:
                    missing_recipes_table += f"<tr><td>{recipe}</td></tr>"
                missing_recipes_table += "</tbody></table>"

                flash(Markup(
                    f"Recipe not found for the following dishes. Kindly update recipe for all the dishes and continue:<br>{missing_recipes_table}"), "danger")
            else:
                # Process the data and update the daily_sales table
                df = pd.read_excel(file_path)
                # Extract sales date from filename format: Restaurant_item_tax_report_YYYY_MM_DD_HH_MM_SS.xlsx
                # filename_parts = file.filename.split('_')
                # sales_date_str = f"{filename_parts[4]}-{filename_parts[5]}-{filename_parts[6]}"
                # sales_date = datetime.strptime(sales_date_str, '%Y-%m-%d').date()

                conn = get_db_connection()
                cursor = conn.cursor()
                sales_report_data = []
                for index, row in df.iterrows():
                    temp = {}
                    temp["category"] = row['Category']
                    temp["item_name"] = row['Item Name']
                    temp["quantity"] = row['Qty']
                    cursor.execute(
                        "SELECT id FROM dishes WHERE category = %s AND name = %s", (temp["category"], temp["item_name"]))
                    dish = cursor.fetchone()
                    app.logger.debug(f"dish fetchone one {dish}")
                    if dish:
                        dish_id = dish[0]
                        temp["dish_id"] = dish_id
                        cursor.execute("""
                            INSERT INTO daily_sales (sales_date, dish_id, restaurant_id, quantity)
                            VALUES (%s, %s, %s, %s)
                            ON DUPLICATE KEY UPDATE quantity = quantity + VALUES(quantity)
                        """, (sales_date, dish_id, restaurant_id, temp["quantity"]))
                    else:
                        missing_recipes.append(temp["item_name"])
                    sales_report_data.append(temp)

                conn.commit()
                cursor.close()
                conn.close()

                # Delete the uploaded Excel file
                os.remove(file_path)
                adjust_stocks(sales_report_data, sales_date, restaurant_id)
                flash("Sales report data has been processed succesfully and the inventory stocks have been adjusted accordingly. Please do not reupload the sales report as it will modify the inventory.", "success")
            return redirect(url_for('upload_sales_report'))

    restaurants = get_all_restaurants(only_active=True)
    return render_template('upload_sales_report.html', user=session["user"], restaurants=restaurants, current_date=get_current_date())


@app.route('/get_available_quantity', methods=['GET'])
def get_available_quantity():
    storageroom_id = int(request.args.get('storageroom_id'))
    raw_material_id = request.args.get('raw_material_id')
    app.logger.debug(f"ss {storageroom_id}")
    app.logger.debug(f"rm {raw_material_id}")
    available_quantity = get_storageroom_rawmaterial_quantity(storageroom_id, raw_material_id)
    storage_available_quantity = 0
    if available_quantity:
        storage_available_quantity = available_quantity[0]["quantity"]
    app.logger.debug(f"storage_available_quantity {storage_available_quantity}")
    # # Check if storage room and raw material exist
    # available_quantity = storage_available_quantity.get(raw_material_id, 0)
    data = {"available_quantity": float(storage_available_quantity)}
    app.logger.debug(f"jsonify data {data}")
    return jsonify(data)


@app.route('/add_prepared_dishes', methods=['GET', 'POST'])
def add_prepared_dishes():
    if "user" not in session:
        return redirect("/login")

    if request.method == "POST":
        # try:
        # Retrieve form data
        dish_categories = request.form.getlist('dish_categories[]')
        dish_names = request.form.getlist('dish_names[]')
        prepared_quantities = request.form.getlist('prepared_quantities[]')
        prepared_in_kitchen = request.form.get('kitchen_id')
        prepared_on = request.form.get('prepared_on')

        for category, dish, quantity in zip(dish_categories, dish_names, prepared_quantities):
            quantity = Decimal(quantity)
            # Validate dish existence
            dish_query = """
                SELECT id FROM dishes 
                WHERE category = %s AND name = %s
            """
            dish_data = fetch_one(dish_query, (category, dish))
            if not dish_data:
                flash(f"Dish '{dish}' under category '{category}' does not exist. Please add the dish.", "error")
                return redirect(request.url)
            dish_id = dish_data['id']

            # Check if the dish exists for the given kitchen and date
            existing_record = fetch_one(
                """
                SELECT id FROM kitchen_prepared_dishes 
                WHERE prepared_dish_id = %s AND prepared_in_kitchen = %s AND prepared_on = %s
                """,
                (dish_id, prepared_in_kitchen, prepared_on)
            )

            if existing_record:
                # Update quantity if record exists
                execute_query(
                    """
                    UPDATE kitchen_prepared_dishes 
                    SET prepared_quantity = prepared_quantity + %s, 
                        available_quantity = available_quantity + %s 
                    WHERE id = %s
                    """,
                    (quantity, quantity, existing_record['id'])
                )
            else:
                # Insert new record
                execute_query(
                    """
                    INSERT INTO kitchen_prepared_dishes 
                    (prepared_dish_id, prepared_quantity, available_quantity, prepared_in_kitchen, prepared_on) 
                    VALUES (%s, %s, %s, %s, %s)
                    """,
                    (dish_id, quantity, quantity, prepared_in_kitchen, prepared_on)
                )

            # Update kitchen stock
            update_kitchen_stock(prepared_in_kitchen, dish_id, quantity, prepared_on)

        flash("Prepared dishes added successfully!", "success")
        return redirect('/add_prepared_dishes')

        # except Exception as e:
        #     app.logger.error(f"Error while adding prepared dishes: {e}")
        #     flash("An error occurred while adding prepared dishes.", "error")
        #     return redirect(request.url)

    # GET request: fetch data for rendering the page
    dish_categories = get_unique_dish_categories()
    dishes = get_all_dishes()
    kitchens = get_all_kitchens(only_active=True)

    # Organize dishes by category
    dish_mapping = {}
    for dish in dishes:
        dish_mapping.setdefault(dish['category'], []).append(dish['name'])

    return render_template(
        'add_prepared_dishes.html',
        dish_categories=dish_categories,
        dish_mapping=dish_mapping,
        kitchens=kitchens,
        user=session["user"],
        todays_date=get_current_date()
    )


@app.route('/list_prepared_dishes', methods=['GET', 'POST'])
def list_prepared_dishes():
    if "user" not in session:
        return redirect("/login")
    if request.method == 'POST':
        prepared_date = request.form['prepared_date']
        app.logger.debug(f"prepared_date {prepared_date}")
        prepared_dishes = get_all_prepared_dishes(prepared_date)
        return render_template('list_prepared_dishes.html', user=session["user"], prepared_dishes=prepared_dishes, current_date=prepared_date)
    return render_template('list_prepared_dishes.html', user=session["user"])


@app.route('/userlist', methods=['GET', 'POST'])
def userlist():
    if "user" not in session:
        return redirect("/login")
    users = get_all_users()

    return render_template('userlist.html', user=session["user"], users=users)


@app.route('/transfer_prepared_dishes', methods=['GET', 'POST'])
def transfer_prepared_dishes():
    if "user" not in session:
        return redirect("/login")

    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)

    # Fetch dishes, restaurants, and kitchens to populate in the form
    prepared_dishes_today = get_prepared_dishes_today()
    dish_categories = list(set([dish["prepared_dish_category"] for dish in prepared_dishes_today]))
    kitchens = get_all_kitchens(only_active=True)
    restaurants = get_all_restaurants(only_active=True)

    current_date = get_current_date()
    app.logger.debug(f"dish_categories {dish_categories}")
    app.logger.debug(f"prepared_dishes_today {prepared_dishes_today}")
    app.logger.debug(f"restaurants {restaurants}")
    app.logger.debug(f"kitchens {kitchens}")

    # Handle form submission for dish transfer
    if request.method == 'POST':
        source_kitchen_id = request.form['kitchen']
        app.logger.debug(f"source_kitchen_id {source_kitchen_id}")
        destination_restaurant_id = request.form['destination_name']
        app.logger.debug(f"destination_restaurant_id {destination_restaurant_id}")
        dish_categories = request.form.getlist('dish_categories[]')
        app.logger.debug(f"dish_categories {dish_categories}")
        dish_names = request.form.getlist('dish_names[]')
        app.logger.debug(f"dish_names {dish_names}")
        transferred_quantities = request.form.getlist('transferred_quantities[]')
        app.logger.debug(f"transferred_quantities {transferred_quantities}")
        transfer_date = request.form['transfer_date']
        app.logger.debug(f"transfer_date {transfer_date }")

        # try:
        conn = get_db_connection()
        cursor = conn.cursor()
        # Insert the transfer details into the database
        for category, name, quantity in zip(dish_categories, dish_names, transferred_quantities):
            dish_id = get_dish_details_from_category(category, name)[0]["id"]
            cursor.execute(
                """
                SELECT available_quantity FROM kitchen_prepared_dishes
                WHERE prepared_dish_id=%s AND prepared_in_kitchen = %s AND prepared_on=%s
                """,
                (dish_id, source_kitchen_id, transfer_date)
            )
            dish = cursor.fetchone()
            app.logger.debug(f"dishhhh {dish}")
            if dish and dish[0] >= int(quantity):
                cursor.execute("""
                INSERT INTO prepared_dish_transfer (
                    source_kitchen_id,
                    destination_restaurant_id,
                    dish_id,
                    quantity,
                    transferred_date
                ) VALUES (%s, %s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE 
                    quantity = quantity + VALUES(quantity);
                """, (source_kitchen_id, destination_restaurant_id, dish_id, quantity, transfer_date))

                # Update the available quantity in the source kitchen
                cursor.execute(
                    """
                    UPDATE kitchen_prepared_dishes
                    SET available_quantity = available_quantity - %s
                    WHERE prepared_dish_id=%s AND prepared_in_kitchen = %s AND prepared_on=%s
                    """,
                    (quantity, dish_id, source_kitchen_id, transfer_date)
                )
                conn.commit()
            else:
                flash(f"Insufficient quantity for dish: {name} in category: {category}", "danger")
                conn.rollback()
                cursor.close()
                conn.close()
                return redirect(url_for('transfer_prepared_dishes'))

        flash("Dish transfer successful!", "success")

        # except Exception as e:
        #     conn.rollback()  # Rollback in case of any error
        #     app.logger.error(f"Error during dish transfer: {e}")
        #     flash("Error occurred while transferring the dish.", "danger")
        # finally:
        #     cursor.close()
        #     conn.close()

        return redirect(url_for('transfer_prepared_dishes'))

    return render_template('transfer_prepared_dishes.html', dish_categories=dish_categories, current_date=current_date, prepared_dishes_today=prepared_dishes_today, restaurants=restaurants, kitchens=kitchens, user=session["user"])


@app.route('/check_dish_availability', methods=['GET', 'POST'])
def check_dish_availability():
    if "user" not in session:
        return redirect("/login")
    if request.method == 'POST':
        selected_date = request.form['selected_date']
        restaurant_id = request.form['restaurant_id']

        # Establish DB connection
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)

        # Query to get dish details for the selected restaurant and date
        query = """
        SELECT d.name, d.category, SUM(pdt.quantity) AS quantity_available
        FROM prepared_dish_transfer pdt
        JOIN dishes d ON pdt.dish_id = d.id
        WHERE pdt.destination_restaurant_id = %s
        AND pdt.transferred_date = %s
        GROUP BY pdt.dish_id
        """
        cursor.execute(query, (restaurant_id, selected_date))
        dishes = cursor.fetchall()

        cursor.close()
        conn.close()

        # Render the page with the fetched data
        return render_template('check_dish_availability.html', dishes=dishes, restaurants=get_restaurants(), user=session["user"])

    # Fetch restaurants to show in the dropdown
    return render_template('check_dish_availability.html', restaurants=get_restaurants(), user=session["user"])

# Function to fetch restaurant data for the dropdown


def get_restaurants():
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    cursor.execute("SELECT id, restaurantname, restaurantcode FROM restaurant")
    restaurants = cursor.fetchall()
    cursor.close()
    conn.close()
    return restaurants


# Read the Excel file
def read_excel(file_path):
    return pd.read_excel(file_path)


def process_data(file_path):

    data = read_excel(file_path)
    missing_recipes = []

    for index, row in data.iterrows():
        category = row['Category']
        item_name = row['Item Name']
        # Find dish_id
        dish = get_dish_details_from_category(category, item_name)

        if dish:
            dish_id = dish[0]["id"]
            dish_recipe = get_dish_recipe(dish_id)
            if not dish_recipe:
                missing_recipes.append(f"{category} - {item_name}")
        else:
            missing_recipes.append(f"{category} - {item_name}")
    return missing_recipes


def adjust_stocks(sales_report_data, report_date, restaurant_id):
    conn = get_db_connection()
    if not conn:
        print("Failed to connect to the database.")
        return []
    app.logger.debug(report_date)
    # data = get_sales_report_data(report_date)
    for dish_data in sales_report_data:
        app.logger.debug(f"dish data for loop {dish_data}")
        dish_recipe = get_dish_recipe(dish_data["dish_id"])
        app.logger.debug(f"dish recipeee {dish_recipe}")
        transferred_dish = check_dish_transferred(dish_data["dish_id"], report_date, restaurant_id)
        if transferred_dish:
            app.logger.debug(f"{dish_data} is a prepared dish")
            pass
        else:
            update_restaurant_stock(restaurant_id, dish_data["dish_id"], dish_data["quantity"], report_date)
        #     materials = get_raw_materials(dish_data["dish_id"])
        #     raw_materials = []
        #     for material in materials:
        #         raw_materials.append({
        #             'raw_material_id': material[0],
        #             'quantity': material[1] * dish_data["quantity"],
        #             'metric': material[2]
        #         })
        #     app.logger.debug(f"raw raw {raw_materials}")
        #     subtract_raw_materials(raw_materials, "restaurant", restaurant_id, report_date)
        # # transferred_dish = check_dish_transferred(dish_data["id"], report_date, restaurant_id)
        # # if transferred_dish:
        # #     pass
        # #     # subtract_raw_materials(raw_materials, "kitchen", transferred_dish[0], report_date)

        # else:
        #     subtract_raw_materials(raw_materials, "restaurant", restaurant_id, report_date)


@app.route('/restaurant_consumption', methods=['GET', 'POST'])
def restaurant_consumption():
    if "user" not in session:
        return redirect("/login")
    restaurants = get_all_restaurants(only_active=True)
    if request.method == 'POST':
        selected_date = request.form['report_date']
        restaurant_id = request.form['restaurant_id']
        app.logger.debug(f"selected_date {selected_date}")
        app.logger.debug(f"restaurant_id {restaurant_id}")
        consumption_data = get_restaurant_consumption_report(restaurant_id, selected_date)
        return render_template("restaurant_consumption.html", user=session["user"], restaurants=restaurants, current_date=selected_date, query_result=consumption_data)
    return render_template("restaurant_consumption.html", user=session["user"], restaurants=restaurants, current_date=get_current_date())


@app.route('/kitchen_consumption', methods=['GET', 'POST'])
def kitchen_consumption():
    if "user" not in session:
        return redirect("/login")
    kitchens = get_all_kitchens(only_active=True)
    if request.method == 'POST':
        selected_date = request.form['report_date']
        kitchen_id = request.form['kitchen_id']
        app.logger.debug(f"selected_date {selected_date}")
        app.logger.debug(f"kitchen_id {kitchen_id}")
        consumption_data = get_kitchen_consumption_report(kitchen_id, selected_date)
        return render_template("kitchen_consumption.html", user=session["user"], kitchens=kitchens, current_date=selected_date, query_result=consumption_data)
    return render_template("kitchen_consumption.html", user=session["user"], kitchens=kitchens, current_date=get_current_date())


@app.route("/api/purchase_trend")
def purchase_trend():
    year = request.args.get("year", type=int)
    app.logger.debug(f"yearr {year}")
    query = """
        SELECT MONTH(purchase_date) AS month, SUM(total_cost) AS purchase_amount
        FROM purchase_history
        WHERE YEAR(purchase_date) = %s
        GROUP BY MONTH(purchase_date)
        ORDER BY MONTH(purchase_date);
    """

    connection = get_db_connection()
    with connection.cursor() as cursor:
        cursor.execute(query, (year,))
        result = cursor.fetchall()

    connection.close()
    app.logger.debug(f"result {result}")

    # Mapping database results to required format
    months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    purchase_data = {row[0]: row[1] for row in result}

    purchase_amounts = [purchase_data.get(i+1, 0) for i in range(12)]  # Fill missing months with 0

    response = {
        "year": year,
        "months": months,
        "purchase_amounts": purchase_amounts
    }
    app.logger.debug(f"res {response}")

    return jsonify(response)
    # return {
    #     "year": 2025,
    #     "months": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    #     "purchase_amounts": [12000, 15000, 18000, 11000, 9000, 20000, 25000, 23000, 17000, 19000, 22000, 24000]
    # }


if __name__ == "__main__":
    app.run(debug=True)
