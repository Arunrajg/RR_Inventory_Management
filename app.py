import pandas as pd
from decimal import Decimal
import logging
from flask import Flask, render_template, request, redirect, flash, session, url_for, jsonify
from markupsafe import Markup
from flask_mail import Mail, Message
from db_utils import *
from encryption import encrypt_message, decrypt_message, generate_random_password
from datetime import datetime, timedelta
from werkzeug.utils import secure_filename
import os
import pytz
from dotenv import load_dotenv
load_dotenv()
# Get the current working directory
current_workspace = os.getcwd()

# Define the path for the uploads folder
UPLOAD_FOLDER = os.path.join(current_workspace, 'uploads')

# Create the uploads folder if it doesn't already exist
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

# ALLOWED_EXTENSIONS = {'txt', 'csv', 'xlsx'}

app = Flask(__name__)
app.secret_key = os.getenv("FLASK_SECRET_KEY", "default_fallback_secret")
encryption_key = bytes(os.getenv("ENCRYPTION_KEY", "b'default_fallback_key'")[2:-1], "utf-8")

app.logger.setLevel(logging.INFO)
# Mail configuration for Gmail
app.config['MAIL_SERVER'] = 'smtp.gmail.com'
app.config['MAIL_PORT'] = 587
app.config['MAIL_USERNAME'] = os.getenv("MAIL_USERNAME")
app.config['MAIL_PASSWORD'] = os.getenv("MAIL_PASSWORD")
app.config['MAIL_USE_TLS'] = True
app.config['MAIL_USE_SSL'] = False

app.config['UPLOAD_FOLDER'] = UPLOAD_FOLDER
app.config['MAX_CONTENT_LENGTH'] = 16 * 1024 * 1024  # 16 MB

mail = Mail(app)


@app.before_request
def make_session_permanent():
    session.permanent = True
    app.permanent_session_lifetime = timedelta(minutes=150)
# Send email function


def send_email(to_email, new_password):
    try:
        msg = Message(
            'Your New Password',
            sender='dharaniinventorysolution@gmail.com',
            recipients=[to_email]
        )
        msg.body = f"Your new password is: {new_password}\nPlease log in and change it immediately. This is a autogenerated mail. Please do not reply to this email."
        mail.send(msg)
    except Exception as e:
        app.logger.error(f"Error sending email: {e}")
        raise e


def get_current_date():

    # Get the IST timezone
    ist_timezone = pytz.timezone('Asia/Kolkata')

    # Get current time in IST
    current_time_ist = datetime.now(ist_timezone)

    # Format the date as "YYYY-MM-DD"
    formatted_date_ist = current_time_ist.strftime("%Y-%m-%d")
    return formatted_date_ist


def get_current_datetime():

    # Get the IST timezone
    ist_timezone = pytz.timezone('Asia/Kolkata')

    # Get current time in IST
    current_time_ist = datetime.now(ist_timezone)

    # Format the date as "YYYY-MM-DD"
    formatted_datetime_ist = current_time_ist.strftime("%Y-%m-%d %H:%M:%S")
    return formatted_datetime_ist


@app.route("/")
@app.route("/login", methods=["GET", "POST"])
def login():
    if request.method == "POST":
        email = request.form["email"].strip()
        password = request.form["password"].strip()
        existing_user = get_user_by_email(email)
        if not existing_user:
            flash("User doesnot exist with this email. Please Sign Up and Create a new account.", "danger")
            return render_template("login.html")
        elif existing_user:
            if existing_user["status"] == "inactive":
                flash("User Account has been made Inactive. Kindy contact the Admin to activate the account.", "danger")
            else:
                decrypted_password = decrypt_message(existing_user["password"], encryption_key)
                existing_user.pop("password")
                if decrypted_password == password:
                    session['user'] = existing_user
                    return redirect("/index")
                else:
                    flash("Invalid Email or Password", "danger")
            return render_template("login.html")
    return render_template("login.html")


@app.route("/signup", methods=["GET", "POST"])
def signup():
    if request.method == "POST":
        username = request.form["username"].strip()
        email = request.form["email"].strip()
        password = request.form["password"].strip()
        # Check if the email is already registered

        existing_user = get_user_by_email(email)

        if existing_user:
            # Email already exists
            flash("User already exists with this email. Please log in or use a different email.", "danger")
        else:
            password = encrypt_message(password, encryption_key)
            # Insert new user details
            insert_query = """
                INSERT INTO users (username, email, password, role)
                VALUES (%s, %s, %s, %s)
            """
            if execute_query(insert_query, (username, email, password, "user")):
                flash("Account created successfully! Click Sign In to login with your account.", "success")
            else:
                flash("Error: Unable to create account. Please try again later.", "danger")

        return redirect("/signup")
    return render_template("signup.html")


@app.route("/index", methods=["GET", "POST"])
def index():
    if "user" not in session:
        return redirect("/login")
    cost_details = get_total_cost_stats()[0]
    return render_template("index.html", user=session["user"], cost_details=cost_details)


@app.route('/api/years', methods=['GET'])
def get_years():
    years = get_purchase_years()
    return jsonify(years)


@app.route("/forgotpassword", methods=["GET", "POST"])
def forgot_password():
    if request.method == 'POST':

        email = request.form['email']
        user = get_user_by_email(email)

        if user is None:
            flash('User with the entered email not found.', 'error')
            return redirect(url_for('forgot_password'))
        else:
            # Generate a new password
            new_password = generate_random_password()
            new_encrypted_password = encrypt_message(new_password, key=encryption_key)
            # Update the password in the database
            status = update_user_password(new_encrypted_password, email)
            # Send the email
            try:
                send_email(email, new_password)
                flash('An email has been sent with the new password. Please log in with the new password.', 'success')
            except Exception:
                flash('Failed to send email. Please contact support.', 'error')

            return redirect(url_for('forgot_password'))
    return render_template('forgotpassword.html')


@app.route("/changepassword", methods=["GET", "POST"])
def change_password():
    if "user" not in session:
        return redirect("/login")
    if request.method == 'POST':

        email = session["user"]['email']
        new_password = request.form["newpassword"]
        current_password = request.form["currentpassword"]
        user = get_user_by_email(email)
        if current_password != decrypt_message(user["password"], encryption_key):
            flash("Current password is wrong. kindly provide the correct password")
            return redirect(url_for("change_password"))
        else:
            new_encrypted_password = encrypt_message(new_password, key=encryption_key)
            # Update the password in the database
            status = update_user_password(new_encrypted_password, email)
            if status:
                flash('Password has been changed successfully.', 'success')
            else:
                flash('Failed to change the password. Please contact support.', 'error')
            return redirect(url_for("change_password"))

    return render_template('changepassword.html', user=session["user"])


@app.route("/addstorageroom", methods=["GET", "POST"])
def addstorageroom():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        storageroom_name = request.form["storageroom_name"].strip()
        address = request.form["address"].strip()
        existing_storageroom = get_storageroom_by_name(storageroom_name)
        if existing_storageroom:
            flash("Storage Room with same name already exists. Please use a different Storage Room Name.", "danger")
        else:
            insert_query = """
                INSERT INTO storagerooms (storageroomname, address)
                VALUES (%s, %s)
            """
            if execute_query(insert_query, (storageroom_name, address)):
                flash("Storage Room added successfully!", "success")
            else:
                flash("Error: Unable to add a new Storage Room. Please try again later.", "danger")
        return redirect("/addstorageroom")
    return render_template("addstorageroom.html", user=session["user"])


@app.route("/storageroomlist", methods=["GET", "POST"])
def storageroomlist():
    if "user" not in session:
        return redirect("/login")
    storagerooms = get_all_storagerooms()
    return render_template("storageroomlist.html", user=session["user"], storagerooms=storagerooms)


@app.route('/editstorageroom', methods=['POST'])
def edit_storage_room():
    # Get data from the form
    room_id = request.form.get('id')
    room_status = request.form.get('status')
    room_address = request.form.get('address')

    # Validate inputs
    if not room_id or not room_address:
        flash("All fields are required.", "error")
        return redirect(url_for('storage_rooms_list'))

    # SQL query to update the storage room
    query = """
        UPDATE storagerooms
        SET address = %s, status= %s
        WHERE id = %s
    """
    params = (room_address, room_status, room_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("Storage room details updated successfully.", "success")
    else:
        flash("Failed to update the storage room details. Please try again.", "danger")

    # Redirect back to the storage rooms list
    return redirect(url_for('storageroomlist'))


@app.route("/addmiscitem", methods=["GET", "POST"])
def addmiscitem():
    if "user" not in session:
        return redirect("/login")

    user = session["user"]  # Assuming session["user"] is a dict
    role = user.get("role")

    # Default selected restaurant
    selected_restaurant_id = None
    if role == "branch_manager":
        selected_restaurant_id = 1  # KTC NAGAR ID

    # Get active restaurants for the dropdown
    restaurants = []
    if request.method == "GET":
        restaurant_query = "SELECT id, restaurantname FROM restaurant WHERE status = 'active'"
        restaurants = fetch_all(restaurant_query)

    if request.method == "POST":
        type_of_expense = request.form["type_of_expense"].strip()
        sub_category = request.form.get("sub_category", "").strip()
        restaurant_id = request.form.get("restaurant_id", "").strip()
        branch_manager = request.form.get("branch_manager", "").strip()
        cost = request.form["cost"].strip()
        notes = request.form.get("notes", "").strip()

        # Convert empty string to None for optional fields
        restaurant_id = int(restaurant_id) if restaurant_id else None
        sub_category = sub_category if sub_category else None
        branch_manager = branch_manager if branch_manager else None
        notes = notes if notes else None

        insert_query = """
        INSERT INTO miscellaneous_items 
        (type_of_expense, sub_category, restaurant_id, branch_manager, cost, notes)
        VALUES (%s, %s, %s, %s, %s, %s)
        """
        if execute_query(insert_query, (type_of_expense, sub_category, restaurant_id, branch_manager, cost, notes)):
            flash("Miscellaneous item added successfully!", "success")
        else:
            flash("Error adding miscellaneous item. Please try again.", "danger")
        return redirect("/addmiscitem")

    return render_template(
        "addmiscitem.html",
        user=user,
        restaurants=restaurants,
        selected_restaurant_id=selected_restaurant_id
    )

# Miscellaneous Item List

@app.route("/miscitemlist", methods=["GET"])
def miscitemlist():
    if "user" not in session:
        return redirect("/login")

    user = session["user"]
    role = user["role"]

    contact_details = get_contact_details()

    # Modified query to include restaurant name
    query = """
    SELECT 
        mi.id,
        mi.type_of_expense,
        mi.sub_category,
        mi.cost,
        mi.notes,
        mi.restaurant_id,
        r.restaurantname,  # Add this line
        mi.branch_manager,
        mi.created_at
    FROM miscellaneous_items mi
    LEFT JOIN restaurant r ON mi.restaurant_id = r.id  # Add this join
    WHERE 1=1
    """
    params = []

    # Only show today's records for admin & branch_manager
    if role in ["admin", "branch_manager", "store_manager"]:
        query += " AND DATE(mi.created_at) = CURDATE()"

    query += " ORDER BY mi.id DESC"

    # Fetch misc items
    misc_items = fetch_all(query, params)

    # Get restaurants for dropdown (unchanged)
    restaurants = fetch_all(
        "SELECT id, restaurantname FROM restaurant WHERE status = 'active'"
    )

    return render_template(
        "miscitemlist.html",
        user=user,
        contact_details=contact_details,
        misc_items=misc_items,
        total_cost=sum(float(item['cost']) for item in misc_items),
        restaurants=restaurants
    )

# Edit Miscellaneous Item
@app.route("/editmiscitem", methods=["POST"])
def edit_misc_item():
    if "user" not in session:
        return redirect("/login")

    # Get all form data (removed status)
    item_id = request.form.get('id')
    type_of_expense = request.form.get('type_of_expense', '').strip()
    sub_category = request.form.get('sub_category', '').strip()
    restaurant_id = request.form.get('restaurant_id', '').strip()
    branch_manager = request.form.get('branch_manager', '').strip()
    cost = request.form.get('cost', '').strip()
    notes = request.form.get('notes', '').strip()

    # Validate required fields
    if not item_id or not type_of_expense:
        flash("Type of expense is required.", "error")
        return redirect(url_for('miscitemlist'))

    # Convert empty strings to None for optional fields
    sub_category = sub_category if sub_category else None
    restaurant_id = int(restaurant_id) if restaurant_id else None
    branch_manager = branch_manager if branch_manager else None
    notes = notes if notes else None

    # Build the update query (removed status)
    query = """
    UPDATE miscellaneous_items
    SET
        type_of_expense = %s,
        sub_category = %s,
        restaurant_id = %s,
        branch_manager = %s,
        cost = %s,
        notes = %s,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = %s
    """
    params = (
        type_of_expense,
        sub_category,
        restaurant_id,
        branch_manager,
        cost,
        notes,
        item_id
    )

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("Miscellaneous item updated successfully.", "success")
    else:
        flash("Failed to update miscellaneous item.", "danger")

    return redirect(url_for('miscitemlist'))

@app.route("/misc_item_report", methods=["GET"])
def misc_item_report():
    if "user" not in session:
        return redirect("/login")

    user = session["user"]
    
    contact_details = get_contact_details()

    # Get filter parameters
    search = request.args.get("search", "").strip()
    date_from = request.args.get("date_from")
    date_to = request.args.get("date_to")

    # Base query
    query = """
    SELECT 
        mi.*,
        r.restaurantname as branch_name
    FROM miscellaneous_items mi
    LEFT JOIN restaurant r ON mi.restaurant_id = r.id
    WHERE 1=1
    """
    params = []

    # Apply search filter
    if search:
        query += " AND (mi.type_of_expense LIKE %s OR mi.sub_category LIKE %s)"
        params.extend([f"%{search}%", f"%{search}%"])

    # Apply date filters
    if date_from:
        query += " AND DATE(mi.created_at) >= %s"
        params.append(date_from)
    
    if date_to:
        query += " AND DATE(mi.created_at) <= %s"
        params.append(date_to)

    # For non-admin roles, only show today's records
    if user["role"] not in ["admin", "branch_manager", "store_manager"]:
        query += " AND DATE(mi.created_at) = CURDATE()"

    query += " ORDER BY mi.created_at DESC"

    # Fetch records
    misc_items = fetch_all(query, tuple(params)) if params else fetch_all(query)

    return render_template(
        "misc_item_report.html",
        user=user,
        misc_items=misc_items,
        contact_details=contact_details,
        total_cost=sum(float(item.get('cost', 0)) for item in misc_items)
    )

@app.route('/editkitchen', methods=['POST'])
def edit_kitchen():
    # Get data from the form
    kitchen_id = request.form.get('id')
    kitchen_status = request.form.get('status')
    kitchen_address = request.form.get('address')

    # Validate inputs
    if not kitchen_id or not kitchen_address:
        flash("All fields are required.", "error")
        return redirect(url_for('kitchenlist'))

    # SQL query to update the kitchen
    query = """
        UPDATE kitchen
        SET address = %s, status= %s
        WHERE id = %s
    """
    params = (kitchen_address, kitchen_status, kitchen_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("Kitchen details updated successfully.", "success")
    else:
        flash("Failed to update the Kitchen details. Please try again.", "danger")

    # Redirect back to the kitchen list
    return redirect(url_for('kitchenlist'))


@app.route('/editrestaurant', methods=['POST'])
def edit_restaurant():
    # Get data from the form
    restaurant_id = request.form.get('id')
    restaurant_status = request.form.get('status')
    restaurant_address = request.form.get('address')

    # Validate inputs
    if not restaurant_id or not restaurant_address:
        flash("All fields are required.", "error")
        return redirect(url_for('restaurantlist'))

    # SQL query to update the restaurant
    query = """
        UPDATE restaurant
        SET address = %s, status= %s
        WHERE id = %s
    """
    params = (restaurant_address, restaurant_status, restaurant_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("restaurant details updated successfully.", "success")
    else:
        flash("Failed to update the restaurant details. Please try again.", "danger")

    # Redirect back to the restaurant list
    return redirect(url_for('restaurantlist'))


@app.route('/editrawmaterial', methods=['POST'])
def edit_rawmaterial():
    # Get data from the form
    rawmaterial_id = request.form.get('id')
    rawmaterial_category = request.form.get('category')
    rawmaterial_name = request.form.get('name')
    rawmaterial_metric = request.form.get('metric')
    # SQL query to update the rawmaterial
    query = """
        UPDATE raw_materials
        SET category = %s, name = %s, metric= %s
        WHERE id = %s
    """
    params = (rawmaterial_category, rawmaterial_name, rawmaterial_metric, rawmaterial_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("rawmaterial details updated successfully.", "success")
    else:
        flash("Failed to update the rawmaterial details. Please try again.", "danger")

    # Redirect back to the rawmaterial list
    return redirect(url_for('rawmaterialslist'))


@app.route('/edituser', methods=['POST'])
def edituser():
    # Get data from the form
    user_id = request.form.get('id')
    user_role = request.form.get('role')
    user_status = request.form.get('status')

    # Validate inputs
    if not user_id or not user_role or not user_status:
        flash("All fields are required.", "error")
        return redirect(url_for('userlist'))

    # SQL query to update the user
    query = """
        UPDATE users
        SET role = %s, status= %s
        WHERE id = %s
    """
    params = (user_role, user_status, user_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("user details updated successfully.", "success")
    else:
        flash("Failed to update the user details. Please try again.", "danger")

    # Redirect back to the user list
    return redirect(url_for('userlist'))


@app.route('/invoice_page')
def invoice_page():
    conn = get_db_connection()
    vendors = get_all_vendors()
    conn.close()
    return render_template('invoice.html', user=session["user"], vendors=vendors)


@app.route('/get_invoices/<vendor_id>')
def get_invoices(vendor_id):
    conn = get_db_connection()
    with conn.cursor() as cursor:
        cursor.execute("SELECT DISTINCT invoice_number FROM purchase_history WHERE vendor_id = %s", (vendor_id,))
        invoices = cursor.fetchall()
    conn.close()
    return jsonify(invoices)


@app.route('/get_invoice_dates/<vendor_id>/<invoice_number>')
def get_invoice_dates(vendor_id, invoice_number):
    conn = get_db_connection()
    with conn.cursor() as cursor:
        cursor.execute(
            "SELECT DISTINCT DATE_FORMAT(purchase_date, '%Y-%m-%d') AS purchase_date FROM purchase_history WHERE vendor_id = %s AND invoice_number = %s", (vendor_id, invoice_number))
        invoice_dates = cursor.fetchall()
    conn.close()
    return jsonify(invoice_dates)


@app.route('/get_invoice_data', methods=['POST'])
def get_invoice_data():
    vendor_id = request.json.get('vendor_id')
    from_date = request.json.get('from_date')
    to_date = request.json.get('to_date')

    conn = get_db_connection()
    with conn.cursor() as cursor:
        cursor.execute("""
            SELECT purchase_date AS date, invoice_number AS type, invoice_number AS sr_no, '-' AS payment_mode,
                   total_cost AS credit, 0.0 AS debit, 0.0 AS balance
            FROM purchase_history
            WHERE vendor_id = %s AND purchase_date BETWEEN %s AND %s
            UNION ALL
            SELECT paid_on AS date, 'Payment Out' AS type, invoice_number AS sr_no, mode_of_payment AS payment_mode,
                   0.0 AS credit, amount_paid AS debit, 0.0 AS balance
            FROM payment_records
            WHERE vendor_id = %s AND paid_on BETWEEN %s AND %s
            ORDER BY date
        """, (vendor_id, from_date, to_date, vendor_id, from_date, to_date))
        transactions = cursor.fetchall()
        cursor.execute("SELECT SUM(total_cost) AS total_credit FROM purchase_history WHERE vendor_id = %s AND purchase_date BETWEEN %s AND %s",
                       (vendor_id, from_date, to_date))
        total_credit = cursor.fetchone()[0]
        cursor.execute("SELECT SUM(amount_paid) AS total_debit FROM payment_records WHERE vendor_id = %s AND paid_on BETWEEN %s AND %s",
                       (vendor_id, from_date, to_date))
        total_debit = cursor.fetchone()[0]
    conn.close()

    return jsonify({
        "transactions": transactions,
        "total_credit": total_credit,
        "total_debit": total_debit
    })


@app.route('/editvendor', methods=['POST'])
def edit_vendor():
    # Get data from the form
    vendor_id = request.form.get('id')
    vendor_status = request.form.get('status')
    vendor_address = request.form.get('address')
    vendor_phone = request.form.get('phone')

    # Validate inputs
    if not vendor_id or not vendor_address or not vendor_phone:
        flash("All fields are required.", "error")
        return redirect(url_for('vendorlist'))

    # SQL query to update the vendor
    query = """
        UPDATE vendor_list
        SET address= %s, status= %s, phone=%s
        WHERE id = %s
    """
    params = (vendor_address, vendor_status, vendor_phone, vendor_id)

    # Execute the query
    success = execute_query(query, params)

    if success:
        flash("vendor details updated successfully.", "success")
    else:
        flash("Failed to update the vendor details. Please try again.", "danger")

    # Redirect back to the vendor list
    return redirect(url_for('list_vendors'))


@app.route("/addkitchen", methods=["GET", "POST"])
def addkitchen():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        kitchen_name = request.form["kitchen_name"].strip()
        address = request.form["address"].strip()
        existing_kitchen = get_kitchen_by_name(kitchen_name)
        if existing_kitchen:
            flash("Kitchen with same name already exists. Please use a different Kitchen name.", "danger")
        else:
            insert_query = """
                INSERT INTO kitchen (kitchenname, address)
                VALUES (%s, %s)
            """
            if execute_query(insert_query, (kitchen_name, address)):
                flash("Kitchen added successfully!", "success")
            else:
                flash("Error: Unable to add a new Kitchen. Please try again later.", "danger")
        return redirect("/addkitchen")
    return render_template("addkitchen.html", user=session["user"])


@app.route("/kitchenlist", methods=["GET", "POST"])
def kitchenlist():
    if "user" not in session:
        return redirect("/login")
    kitchens = get_all_kitchens()
    return render_template("kitchenlist.html", user=session["user"], kitchens=kitchens)


@app.route("/addrestaurant", methods=["GET", "POST"])
def addrestaurant():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        restaurant_name = request.form["restaurant_name"].strip()
        address = request.form["address"].strip()
        existing_restaurant = get_restaurant_by_name(restaurant_name)
        if existing_restaurant:
            flash("Restaurant with same name already exists. Please use a different Restaurant name.", "danger")
        else:
            insert_query = """
                INSERT INTO restaurant (restaurantname, address)
                VALUES (%s, %s)
            """
            if execute_query(insert_query, (restaurant_name, address)):
                flash("Restaurant added successfully!", "success")
            else:
                flash("Error: Unable to add a new Restaurant. Please try again later.", "danger")
        return redirect("/addrestaurant")
    return render_template("addrestaurant.html", user=session["user"])


@app.route("/restaurantlist", methods=["GET", "POST"])
def restaurantlist():
    if "user" not in session:
        return redirect("/login")
    restaurants = get_all_restaurants()
    return render_template("restaurantlist.html", user=session["user"], restaurants=restaurants)


@app.route("/addrawmaterials", methods=["GET", "POST"])
def addrawmaterials():
    if "user" not in session:
        return redirect("/login")

    if request.method == "POST":
        raw_materials = request.form.getlist("rawmaterial_name[]")
        metrics = request.form.getlist("metric[]")
        categories = request.form.getlist("materialcategory")

        if len(raw_materials) != len(metrics) or len(raw_materials) != len(categories):
            flash("Error: Inconsistent data. Please try again.", "danger")
            return redirect("/addrawmaterials")

        # Fetch all raw materials, including deleted ones
        existing_materials = get_all_rawmaterials(only_not_deleted=False)

        # Create lookup sets
        existing_rm_dict = {}  # {(name, category, metric): row_data}
        active_raw_materials = set()  # {name} for active raw materials
        deleted_materials = {}  # {(name, category, metric): id} for deleted entries

        for row in existing_materials:
            key = (row["name"].strip().lower(), row["category"].strip().lower(), row["metric"].strip().lower())
            existing_rm_dict[key] = row

            if row["is_deleted"] == 0:
                active_raw_materials.add(row["name"].strip().lower())  # Track all active raw material names
            else:
                deleted_materials[key] = row["id"]

        to_insert = []
        restore_deleted = []
        errors = []
        successes = []

        for raw_material, metric, category in zip(raw_materials, metrics, categories):
            raw_material = raw_material.strip()
            metric = metric.strip()
            category = category.strip()
            key = (raw_material.lower(), category.lower(), metric.lower())

            if not raw_material:
                errors.append("Raw material name cannot be empty.")
                continue

            # Check if any active entry exists with same name (ignoring category & metric)
            if raw_material.lower() in active_raw_materials:
                errors.append(
                    f"Raw material '{raw_material}' already exists with a different category or metric."
                )
                continue  # Do NOT insert or restore

            # If NO active entry exists, check for deleted one with same name/category/metric
            if key in deleted_materials:
                restore_deleted.append(deleted_materials[key])
                successes.append(f"Restored: {raw_material} ({metric}, {category})")
                continue  # No need to insert, just restore

            # If neither active nor deleted exists, allow insertion
            to_insert.append((raw_material, metric, category))

        # Restore deleted materials (only if no active ones exist)
        if restore_deleted:
            restore_query = "UPDATE raw_materials SET is_deleted = 0 WHERE id IN ({})".format(
                ",".join(["%s"] * len(restore_deleted))
            )
            execute_query(restore_query, restore_deleted if len(restore_deleted) > 1 else [restore_deleted], bulk=True)

        # Insert new materials
        if to_insert:
            insert_query = "INSERT INTO raw_materials (name, metric, category) VALUES (%s, %s, %s)"
            if execute_query(insert_query, to_insert, bulk=True):
                successes += [f"Added: {raw_material} ({metric}, {category})" for raw_material,
                              metric, category in to_insert]
            else:
                errors.append("Error: Unable to add some raw materials due to a database issue.")

        # Flash messages
        if successes:
            flash(f"Successfully processed: {', '.join(successes)}.", "success")
        if errors:
            flash(" ".join(errors), "danger")

        return redirect("/addrawmaterials")

    return render_template("addrawmaterials.html", user=session["user"])


@app.route("/rawmaterialslist", methods=["GET", "POST"])
def rawmaterialslist():
    if "user" not in session:
        return redirect("/login")
    rawmaterials = get_all_rawmaterials()
    return render_template("rawmaterialslist.html", user=session["user"], rawmaterials=rawmaterials)


@app.route('/add_dish_recipe', methods=['GET', 'POST'])
def add_dish_recipe():
    if "user" not in session:
        return redirect("/login")

    if request.method == 'POST':
        category = request.form['category']
        name = request.form['name']
        raw_materials = request.form.getlist('raw_materials[]')
        quantities = request.form.getlist('quantities[]')
        metrics = request.form.getlist('metric[]')

        if len(raw_materials) != len(quantities) or len(raw_materials) != len(metrics):
            flash("Error: Mismatched data for raw materials. Please check your input.", "danger")
            return redirect('/add_dish_recipe')

        # try:
        existing_dish = get_dish_details_from_category(category, name)
        if not existing_dish:
            with get_db_connection() as conn:
                with conn.cursor() as cursor:
                    # Insert into `dishes` table
                    cursor.execute("INSERT INTO dishes (category, name) VALUES (%s, %s)", (category, name))
                    dish_id = cursor.lastrowid

                    # Fetch all existing raw materials in one query
                    cursor.execute("SELECT id, name, metric FROM raw_materials")
                    existing_raw_materials = {row[1]: (row[0], row[2])
                                              for row in cursor.fetchall()}

                    # Prepare data for batch inserts
                    new_raw_materials = []
                    dish_raw_materials = []

                    for raw_material, quantity, metric in zip(raw_materials, quantities, metrics):
                        raw_material = raw_material.strip()
                        metric = metric.strip()

                        if raw_material in existing_raw_materials:
                            raw_material_id = existing_raw_materials[raw_material][0]
                        else:
                            # Add to new raw materials batch
                            new_raw_materials.append((raw_material, metric))

                    # Bulk insert new raw materials
                    if new_raw_materials:
                        cursor.executemany(
                            "INSERT INTO raw_materials (name, metric) VALUES (%s, %s)",
                            new_raw_materials
                        )
                        # Update existing_raw_materials with newly added materials
                        cursor.execute("SELECT id, name, metric FROM raw_materials WHERE name IN %s",
                                       ([rm[0] for rm in new_raw_materials],))
                        for row in cursor.fetchall():
                            existing_raw_materials[row['name']] = (row['id'], row['metric'])

                    # Build dish_raw_materials mapping
                    for raw_material, quantity, metric in zip(raw_materials, quantities, metrics):
                        raw_material_id = existing_raw_materials[raw_material][0]
                        dish_raw_materials.append((dish_id, raw_material_id, quantity, metric))

                    # Bulk insert into `dish_raw_materials`
                    cursor.executemany(
                        "INSERT INTO dish_raw_materials (dish_id, raw_material_id, quantity, metric) VALUES (%s, %s, %s, %s)",
                        dish_raw_materials
                    )

                conn.commit()
                flash('Dish added successfully!', 'success')
        else:
            flash('Dish already exists. Kindly check.', 'danger')

        # except Exception as e:
        #     flash(f'Error: {str(e)}', 'danger')

        return redirect('/add_dish_recipe')

    raw_materials = get_all_rawmaterials()
    dish_categories = get_all_dish_categories()

    return render_template('add_dish_recipe.html', user=session["user"], raw_materials=raw_materials, dish_categories=dish_categories)


@app.route('/list_dish_recipe', methods=['GET', 'POST'])
def list_dish_recipe():
    if "user" not in session:
        return redirect("/login")
    # Fetch dishes and their raw materials from the database
    query = """
        SELECT d.id, d.name AS dish_name, d.category,
               rm.name AS raw_material_name, dr.quantity, dr.metric
        FROM dishes d
        JOIN dish_raw_materials dr ON d.id = dr.dish_id
        JOIN raw_materials rm ON dr.raw_material_id = rm.id
        ORDER BY d.id, rm.name
    """
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute(query)
    data = cursor.fetchall()

    # Organize data into a dictionary grouped by dishes
    dishes = {}
    for row in data:
        dish_id, dish_name, category, raw_material_name, quantity, metric = row
        if dish_id not in dishes:
            dishes[dish_id] = {
                "name": dish_name,
                "category": category,
                "raw_materials": []
            }
        dishes[dish_id]["raw_materials"].append({
            "name": raw_material_name,
            "quantity": quantity,
            "metric": metric
        })

    return render_template('list_dish_recipe.html', user=session["user"], dishes=dishes)


@app.route('/get_dish_raw_materials', methods=['GET'])
def get_dish_raw_materials():
    dish_id = int(request.args.get('dish_id'))
    materials_map = get_dish_recipe_raw_materials(dish_id)
    return jsonify({'raw_materials': materials_map})


@app.route('/submit_raw_materials', methods=['POST'])
def submit_raw_materials():
    data = request.get_json()

    dish_id = data["dish_id"]
    incoming_materials = data["materials"]

    # Fetch current materials from the database
    current_materials = get_dish_recipe_raw_materials(dish_id)

    # Map current materials for easy comparison
    current_map = {mat[1]: (mat[2], mat[3]) for mat in current_materials}  # {name: (quantity, metric)}
    incoming_map = {mat["name"]: (float(mat["quantity"]), mat["metric"]) for mat in incoming_materials}

    to_update = []
    to_insert = []
    to_delete = []

    # Identify materials to update or insert
    for name, (quantity, metric) in incoming_map.items():
        if name in current_map:
            # Check if there is a difference
            if current_map[name] != (quantity, metric):
                to_update.append((dish_id, name, quantity, metric))
        else:
            # New material to insert
            to_insert.append((dish_id, name, quantity, metric))

    # Identify materials to delete
    for name in current_map:
        if name not in incoming_map:
            to_delete.append(name)

    # Perform batch updates, inserts, and deletions
    conn = get_db_connection()
    cursor = conn.cursor()
    try:
        # Update materials
        for dish_id, name, quantity, metric in to_update:
            cursor.execute("""
                UPDATE dish_raw_materials AS drm
                JOIN raw_materials AS rm ON drm.raw_material_id = rm.id
                SET drm.quantity = %s, drm.metric = %s
                WHERE drm.dish_id = %s AND rm.name = %s
            """, (quantity, metric, dish_id, name))

        # Insert new materials
        for dish_id, name, quantity, metric in to_insert:
            # Check if the raw material already exists
            cursor.execute("SELECT id FROM raw_materials WHERE name = %s", (name,))
            raw_material = cursor.fetchone()

            if raw_material:
                raw_material_id = raw_material[0]
            else:
                # Insert raw material if not exists
                cursor.execute("INSERT INTO raw_materials (name, metric) VALUES (%s, %s)", (name, metric))
                raw_material_id = cursor.lastrowid

            # Insert into dish_raw_materials
            cursor.execute("""
                INSERT INTO dish_raw_materials (dish_id, raw_material_id, quantity, metric)
                VALUES (%s, %s, %s, %s)
            """, (dish_id, raw_material_id, quantity, metric))

        # Delete removed materials
        for name in to_delete:
            cursor.execute("""
                DELETE drm FROM dish_raw_materials AS drm
                JOIN raw_materials AS rm ON drm.raw_material_id = rm.id
                WHERE drm.dish_id = %s AND rm.name = %s
            """, (dish_id, name))

        conn.commit()
        flash('Raw materials updated successfully', "success")
        return jsonify({
            'message': 'Raw materials updated successfully.',
            'redirect_url': url_for("edit_dish_recipe")  # Include the redirect URL
        }), 200
    except Exception as e:
        conn.rollback()
        app.logger.error(f"Error updating raw materials: {e}")
        flash(f"Error updating raw materials: {e}", "danger")
        return redirect(url_for("edit_dish_recipe"))
    finally:
        cursor.close()
        conn.close()


@app.route("/edit_dish_recipe", methods=['GET', 'POST'])
def edit_dish_recipe():
    if "user" not in session:
        return redirect("/login")
    dish_categories = get_unique_dish_categories()
    dishes = get_all_dishes()
    return render_template('edit_dish_recipe.html', user=session["user"], dish_categories=dish_categories, dishes=dishes)


@app.route('/add_vendor', methods=['GET', 'POST'])
def add_vendor():
    if "user" not in session:
        return redirect("/login")

    if request.method == "POST":
        vendor_names = request.form.getlist("vendor_name[]")
        phone_numbers = request.form.getlist("phone_number[]")
        addresses = request.form.getlist("address[]")
        skipped_vendors = []
        added_vendors = []

        if vendor_names and phone_numbers and addresses:
            try:
                db_connection = get_db_connection()
                cursor = db_connection.cursor()

                # Get existing vendors from the database
                existing_vendors = get_all_vendors()
                existing_vendor_names = [vendor['vendor_name'] for vendor in existing_vendors]

                # Insert each vendor's data into the database
                for name, phone, address in zip(vendor_names, phone_numbers, addresses):
                    name = name.strip()
                    phone = phone.strip()
                    address = address.strip()
                    if name not in existing_vendor_names:
                        cursor.execute(
                            "INSERT INTO vendor_list (vendor_name, phone, address) VALUES (%s, %s, %s)",
                            (name, phone, address)
                        )
                        existing_vendor_names.append(name)
                        added_vendors.append(name)
                    else:
                        skipped_vendors.append(name)

                db_connection.commit()
                cursor.close()
                db_connection.close()

                if added_vendors and skipped_vendors:
                    flash(
                        f'Added vendors: {", ".join(added_vendors)}. Skipped vendors: {", ".join(skipped_vendors)}', 'success')
                elif added_vendors:
                    flash(f'Vendor added successfully! Added vendors: {", ".join(added_vendors)}', 'success')
                elif skipped_vendors:
                    flash(
                        f'Vendors already available. So skipped adding vendors: {", ".join(skipped_vendors)}', 'danger')

            except Exception as e:
                app.logger.error(f"Error: {e}")
                flash("An error occurred while adding vendor details.", 'danger')
            return redirect("/add_vendor")

    return render_template('add_vendor.html', user=session["user"])


@app.route("/list_vendors", methods=["GET", "POST"])
def list_vendors():
    if "user" not in session:
        return redirect("/login")
    vendors = get_all_vendors()
    return render_template("list_vendors.html", user=session["user"], vendors=vendors)


@app.route('/add_purchase', methods=['GET', 'POST'])
def add_purchase():
    if "user" not in session:
        return redirect("/login")

    connection = get_db_connection()
    raw_materials = get_all_rawmaterials()
    storage_rooms = get_all_storagerooms(only_active=True)
    vendors = get_all_vendors(only_active=True)

    if request.method == 'POST':

        vendor_name = request.form.get('vendor')
        storageroom_name = request.form.get('storage_room')
        raw_material_names = request.form.getlist('raw_material[]')
        quantities = request.form.getlist('quantity[]')
        metrics = request.form.getlist('metric[]')
        total_costs = request.form.getlist('total_cost[]')
        purchase_date = request.form.get("purchase_date")
        invoice_number = request.form.get("invoice_number")

        vendor = next((v for v in vendors if v['vendor_name'] == vendor_name), None)
        if not vendor:
            flash('Vendor does not exist. Please add the vendor first.', 'danger')
            return redirect('/add_purchase')

        storageroom = next((s for s in storage_rooms if s['storageroomname'] == storageroom_name), None)
        if not storageroom:
            flash('Storage room does not exist. Please add the storage room first.', 'danger')
            return redirect('/add_purchase')

        try:
            cursor = connection.cursor()

            # Check if the invoice number already exists for the same vendor and date
            cursor.execute(
                """
                SELECT COUNT(*)
                FROM purchase_history
                WHERE vendor_id = %s AND invoice_number = %s AND purchase_date = %s
                """,
                (vendor["id"], invoice_number, purchase_date)
            )
            existing_invoice_count = cursor.fetchone()[0]

            if existing_invoice_count > 0:
                flash('This invoice number already exists for the same vendor on the same day.', 'danger')
                return redirect('/add_purchase')

            for raw_material_name, quantity, metric, cost in zip(raw_material_names, quantities, metrics, total_costs):
                raw_material_name = raw_material_name.strip()
                raw_material = next((rm for rm in raw_materials if rm['name'] == raw_material_name), None)

                if not raw_material:
                    cursor.execute(
                        "INSERT INTO raw_materials (name, metric) VALUES (%s, %s)",
                        (raw_material_name, metric)
                    )
                    connection.commit()
                    raw_material_id = cursor.lastrowid
                else:
                    raw_material_id = raw_material['id']

                quantity, metric = convert_metric(quantity, metric)
                quantity = Decimal(quantity)

                #  Insert or Update Purchase History
                cursor.execute(
                    """
                    INSERT INTO purchase_history
                    (vendor_id, invoice_number, raw_material_id, raw_material_name,
                     quantity, metric, total_cost, purchase_date, storageroom_id)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                    ON DUPLICATE KEY UPDATE
                        quantity = quantity + VALUES(quantity),
                        total_cost = total_cost + VALUES(total_cost);
                    """,
                    (vendor["id"], invoice_number, raw_material_id, raw_material_name,
                     quantity, metric, cost, purchase_date, storageroom['id'])
                )
                #  Update Vendor Payment Tracker
                cursor.execute(
                    """
                    INSERT INTO vendor_payment_tracker (vendor_id, invoice_number, purchase_date, outstanding_cost)
                    VALUES (%s, %s, %s, %s)
                    ON DUPLICATE KEY UPDATE outstanding_cost = outstanding_cost + VALUES(outstanding_cost);
                    """,
                    (vendor['id'], invoice_number, purchase_date, cost)
                )

                # Fetch minimum_quantity first, ensuring it exists
                cursor.execute(
                    """
                    SELECT COALESCE(min_quantity, 0)
                    FROM minimum_stock
                    WHERE type='storageroom' AND destination_id=%s AND raw_material_id=%s
                    """,
                    (storageroom['id'], raw_material_id),
                )
                min_quantity_row = cursor.fetchone()
                min_quantity = min_quantity_row[0] if min_quantity_row else 0  # Ensure default 0 if no entry exists

                # Fetch current stock (if exists)
                cursor.execute(
                    """
                    SELECT currently_available
                    FROM inventory_stock
                    WHERE destination_type='storageroom' AND destination_id=%s AND raw_material_id=%s
                    """,
                    (storageroom['id'], raw_material_id),
                )
                stock_row = cursor.fetchone()
                opening_stock = stock_row[0] if stock_row and stock_row[0] is not None else 0

                # Compute quantity_needed (only if minimum_quantity > available stock)
                new_currently_available = opening_stock + quantity
                new_quantity_needed = max(0, min_quantity - new_currently_available)

                # Insert or Update Stock (Avoiding Subqueries)
                cursor.execute(
                    """
                    INSERT INTO inventory_stock
                    (destination_type, destination_id, raw_material_id, metric,
                    opening_stock, incoming_stock, currently_available, minimum_quantity, quantity_needed)
                    VALUES ('storageroom', %s, %s, %s, %s, %s, %s, %s, %s)
                    ON DUPLICATE KEY UPDATE
                        incoming_stock = incoming_stock + VALUES(incoming_stock),
                        currently_available = currently_available + VALUES(incoming_stock),
                        minimum_quantity = VALUES(minimum_quantity),
                        quantity_needed = GREATEST(0, minimum_quantity - currently_available),
                        updated_at = CURRENT_TIMESTAMP;
                    """,
                    (storageroom['id'], raw_material_id, metric, opening_stock, quantity,
                     new_currently_available, min_quantity, new_quantity_needed)
                )

            #  Commit all changes after successful operations
            connection.commit()
            cursor.close()
            connection.close()
            flash('Purchases added successfully!', 'success')
        except Exception as e:
            connection.rollback()  # Rollback if any issue occurs
            app.logger.error(f"Error in add_purchase: {e}")
            flash(f"An error occurred: {e}", 'danger')

        return redirect('/add_purchase')

    return render_template(
        'add_purchase.html',
        vendors=vendors,
        raw_materials=raw_materials,
        storage_rooms=storage_rooms,
        user=session["user"],
        today_date=get_current_date()
    )


def convert_metric(quantity, metric):
    """
    Convert quantity to base metric (kilograms or liters) if needed.
    """
    quantity = float(quantity)
    if metric == 'grams':
        quantity /= 1000  # Convert grams to kilograms
        metric = 'kg'
    elif metric == 'ml':
        quantity /= 1000  # Convert milliliters to liters
        metric = 'liter'
    return quantity, metric


@app.route('/get_purchases/<vendor_id>/<invoice_number>/<purchase_date>', methods=['GET'])
def get_purchases(vendor_id, invoice_number, purchase_date):
    connection = get_db_connection()
    cursor = connection.cursor()
    cursor.execute("""
        SELECT ph.id, ph.invoice_number, v.vendor_name, ph.raw_material_name, ph.quantity, ph.metric,
               ph.total_cost, ph.purchase_date, sr.storageroomname
        FROM purchase_history ph
        JOIN vendor_list v ON ph.vendor_id = v.id
        JOIN storagerooms sr ON ph.storageroom_id = sr.id
        WHERE ph.vendor_id = %s AND ph.invoice_number = %s AND ph.purchase_date = %s
    """, (vendor_id, invoice_number, purchase_date))
    purchases = [
        {
            "id": row[0],
            "invoice_number": row[1],
            "vendor_name": row[2],
            "raw_material_name": row[3],
            "quantity": row[4],
            "metric": row[5],
            "total_cost": row[6],
            "purchase_date": datetime.strptime(str(row[7]), '%Y-%m-%d').strftime('%A, %d %B %Y'),
            "storageroom_name": row[8]
        }
        for row in cursor.fetchall()
    ]

    total_amount = sum(purchase["total_cost"] for purchase in purchases)

    cursor.close()
    connection.close()
    return jsonify({"purchases": purchases, "total_amount": total_amount})


@app.route('/purchase_list')
def purchase_list():
    if "user" not in session:
        return redirect("/login")
    # purchases = get_all_purchases()
    vendors = get_all_vendors(only_active=True)
    return render_template('purchase_list.html', vendors=vendors, user=session["user"])


@app.route('/purchase_record')
def purchase_record():
    if "user" not in session:
        return redirect("/login")
    # purchases = get_all_purchases()
    today_date = get_current_date()
    vendors = get_all_vendors(only_active=True)
    contact_details = get_contact_details()
    return render_template('purchase_record.html', user=session["user"], contact_details=contact_details, vendors=vendors, today_date=today_date)


@app.route("/get_purchase_transaction", methods=["GET"])
def get_purchase_transaction():
    date = request.args.get("date")
    transactions, total_purchase_amount = get_purchase_record(date=date)
    return jsonify({"purchases": transactions, "total_amount": total_purchase_amount})


@app.route("/get_purchase_records", methods=["GET"])
def fetch_purchase_records():
    vendor_id = request.args.get("vendor_id", "all")
    from_date = request.args.get("from_date")
    to_date = request.args.get("to_date")

    if not from_date or not to_date:
        return jsonify({"error": "Invalid date range"}), 400

    try:
        datetime.strptime(from_date, "%Y-%m-%d")
        datetime.strptime(to_date, "%Y-%m-%d")
    except ValueError:
        return jsonify({"error": "Invalid date format"}), 400

    purchases, vendor_totals = get_purchase_records(vendor_id, from_date, to_date)

    return jsonify({
        "purchases": purchases,
        "vendor_totals": vendor_totals
    })


@app.route("/get_payment_records", methods=["GET"])
def fetch_payment_records():
    vendor_id = request.args.get("vendor_id", "all")
    from_date = request.args.get("from_date")
    to_date = request.args.get("to_date")

    if not from_date or not to_date:
        return jsonify({"error": "Invalid date range"}), 400

    try:
        datetime.strptime(from_date, "%Y-%m-%d")
        datetime.strptime(to_date, "%Y-%m-%d")
    except ValueError:
        return jsonify({"error": "Invalid date format"}), 400

    payments, vendor_totals = get_payment_records(vendor_id, from_date, to_date)

    return jsonify({"payments": payments, "vendor_totals": vendor_totals})


@app.route("/get_pending_payments_record", methods=["GET"])
def fetch_pending_payments_record():
    vendor_id = request.args.get("vendor_id", "all")

    # from_date = request.args.get("from_date")
    # to_date = request.args.get("to_date")

    # if not from_date or not to_date:
    #     return jsonify({"error": "Invalid date range"}), 400

    # try:
    #     datetime.strptime(from_date, "%Y-%m-%d")
    #     datetime.strptime(to_date, "%Y-%m-%d")
    # except ValueError:
    #     return jsonify({"error": "Invalid date format"}), 400

    pending_payments, vendor_totals = get_pending_payments_record(vendor_id)

    return jsonify({"payments": pending_payments, "vendor_totals": vendor_totals})


@app.route("/get_payment_transaction", methods=["GET"])
def get_payment_transaction():
    date = request.args.get("date")

    transactions, total_paid_amount = get_payment_record_on_date(date=date)

    return jsonify({"payments": transactions, "total_amount": total_paid_amount})


@app.route("/pay_vendor", methods=["GET", "POST"])
def pay_vendor():
    if "user" not in session:
        return redirect("/login")
    # if request.method == "POST":
    #     # Handle form submission
    #     vendor_id = request.json.get("vendorId")
    #     vendor_name = request.json.get("vendorName")
    #     amount_paid = float(request.json.get("amountPaid"))
    #     connection = get_db_connection()
    #     cursor = connection.cursor()
    #     cursor.execute(
    #         """
    #             INSERT INTO vendor_payment_tracker (vendor_id, total_paid)
    #             VALUES (%s, %s)
    #             ON DUPLICATE KEY UPDATE total_paid = total_paid + %s
    #             """,
    #         (vendor_id, amount_paid, amount_paid)
    #     )
    #     connection.commit()
    #     cursor.close()
    #     connection.close()
    #     flash('Payment done successfully!', "success")
    #     return redirect(url_for("pending_payments"))
    pending_payments_vendor_cumulative = get_all_pending_payments_vendor_cumulative()
    return render_template("pay_vendor.html", user=session["user"], pending_payments_vendor_cumulative=pending_payments_vendor_cumulative, todays_date=get_current_date())


@app.route("/pending_payments", methods=["GET", "POST"])
def pending_payments():
    if "user" not in session:
        return redirect("/login")
    today_date = get_current_date()
    vendors = get_all_vendors(only_active=True)
    contact_details = get_contact_details()
    return render_template('pending_payments.html', user=session["user"], contact_details=contact_details, vendors=vendors, today_date=today_date)


@app.route("/process_payments", methods=["POST"])
def process_payments():
    # try:
    if request.method == "POST":
        vendor_id = request.json.get("vendor_id")
        paid_values = []
        for payment in request.json.get("payments", []):
            if payment["pay_amount"] > 0:
                paid_values.append(payment)

        connection = get_db_connection()
        cursor = connection.cursor()
        for payment_detail in paid_values:
            cursor.execute(
                """
                    INSERT INTO vendor_payment_tracker (vendor_id, invoice_number, purchase_date, total_paid)
                    VALUES (%s, %s, %s, %s)
                    ON DUPLICATE KEY UPDATE total_paid = total_paid + %s
                    """,
                (vendor_id, payment_detail["invoice_number"], payment_detail["purchase_date"],
                 payment_detail["pay_amount"], payment_detail["pay_amount"])
            )
            cursor.execute(
                """
                    INSERT INTO payment_records (vendor_id, invoice_number, purchase_date, amount_paid, mode_of_payment, paid_on)
                    VALUES (%s, %s, %s, %s, %s, %s)
                    """,
                (vendor_id, payment_detail["invoice_number"], payment_detail["purchase_date"],
                    payment_detail["pay_amount"], payment_detail["mode_of_payment"], payment_detail["date_of_payment"])
            )
        connection.commit()
        cursor.close()
        connection.close()
        flash('Payment processed successfully!', 'success')
        return jsonify({'message': 'Payment processed successfully'}), 200
    # except Exception as e:
    #     flash(f'An error occurred while processing the payment. Please try again. {str(e)}', 'error')
    #     return jsonify({'error': str(e)}), 400


@app.route('/storageroom_stock')
def storageroom_stock():
    if "user" not in session:
        return redirect("/login")
    storage_stock = get_storageroom_stock()

    return render_template('storageroom_stock.html', storage_stock=storage_stock, user=session["user"])


@app.route('/kitchen_inventory_stock')
def kitchen_inventory_stock():
    if "user" not in session:
        return redirect("/login")
    kitcheninv_stock = get_kitchen_inventory_stock()

    return render_template('kitchen_inventory_stock.html', kitcheninv_stock=kitcheninv_stock, user=session["user"])


@app.route('/get_vendor_payments', methods=["GET"])
def get_vendor_payments():
    vendor_id = request.args.get('vendor_id')
    from_date = request.args.get('from_date')
    to_date = request.args.get('to_date')

    # Convert string dates to datetime objects
    try:
        from_date = datetime.strptime(from_date, '%Y-%m-%d')
        to_date = datetime.strptime(to_date, '%Y-%m-%d')
    except ValueError:
        return jsonify({"error": "Invalid date format"}), 400

    # Fetch payment records for the given vendor and date range
    payments_per_vendor = get_payment_details_of_vendor_between_dates(vendor_id, from_date, to_date)

    def serialize(payment):
        return {
            'paid_on': payment['paid_on'].strftime('%Y-%m-%d'),
            'invoice_number': payment['invoice_number'],
            'purchase_date': payment['purchase_date'],
            'mode_of_payment': payment['mode_of_payment'],
            'amount_paid': float(payment['amount_paid'])
        }

    return jsonify({'payments': [serialize(p) for p in payments_per_vendor]})


@app.route("/get_payment_details/<vendor_id>", methods=["GET"])
def get_payment_details(vendor_id):
    # vendor_id = request.args.get('vendor_id')

    payments_per_vendor = get_payment_details_of_vendor(vendor_id)

    def serialize(payment):
        return {
            'payment_id': payment['payment_id'],
            'invoice_number': payment['invoice_number'],
            'purchase_date': payment['purchase_date'],
            'outstanding_cost': float(payment['outstanding_cost']),
            'total_paid': float(payment['total_paid']),
            'total_due': float(payment['total_due'])
        }

    return jsonify([serialize(p) for p in payments_per_vendor])


@app.route("/payment_receipt")
def payment_receipt():
    if "user" not in session:
        return redirect("/login")
    # inv_payment_details = get_invoice_payment_details()
    vendors = get_all_vendors(only_active=True)
    contact_details = get_contact_details()
    return render_template('payment_receipt.html', vendors=vendors, contact_details=contact_details, user=session["user"])


@app.route("/payment_record")
def payment_record():
    if "user" not in session:
        return redirect("/login")
    # payment_record = get_payment_record()
    today_date = get_current_date()
    vendors = get_all_vendors(only_active=True)
    contact_details = get_contact_details()
    return render_template('payment_record.html', user=session["user"], vendors=vendors, contact_details=contact_details, today_date=today_date)


@app.route('/restaurant_inventory_stock')
def restaurant_inventory_stock():
    if "user" not in session:
        return redirect("/login")
    restaurantinv_stock = get_restaurant_inventory_stock()

    return render_template('restaurant_inventory_stock.html', restaurantinv_stock=restaurantinv_stock, user=session["user"])


@app.route("/set_minimum_stock", methods=["GET", "POST"])
def set_minimum_stock():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        # try:
        destination_type = request.form.get("destination_type")
        destination_id = request.form.get("destination_id")
        min_stock_data = {}
        for key, value in request.form.items():

            if key.startswith("min_quantity_"):

                material_id = key.replace("min_quantity_", "")

                min_stock_data[material_id] = float(value)

        result = update_minimum_stock(destination_type, destination_id, min_stock_data)
        if result:
            flash("Minimum stock updated successfully!", "success")
        else:
            flash("Error: Unable to add minimum stock details", "danger")
        # except Exception as e:
        #     flash(f"Error: {str(e)}", "danger")
        return redirect(url_for("set_minimum_stock"))
    return render_template(
        'set_minimum_stock.html',
        raw_materials=get_all_rawmaterials(),
        storage_rooms=get_all_storagerooms(only_active=True),
        restaurants=get_all_restaurants(only_active=True),
        kitchens=get_all_kitchens(only_active=True),
        user=session["user"],
        today_date=get_current_date()
    )


@app.route("/get_raw_materials_min_stock")
def fetch_raw_materials_min_stock():
    if "user" not in session:
        return redirect("/login")

    # Fetch query parameters from request
    destination_type = request.args.get("destination_type")
    destination_id = request.args.get("destination_id")

    if not destination_type or not destination_id:
        return jsonify({"error": "Missing required parameters"}), 400

    # Fetch raw materials with minimum stock details
    rm = get_raw_materials_min_stock(destination_type, destination_id)

    return jsonify(rm)  # Return as JSON response


@app.route("/get_raw_materials_stock_report")
def fetch_raw_materials_stock_report():
    if "user" not in session:
        return redirect("/login")

    # Fetch query parameters from request
    destination_type = request.args.get("destination_type")
    destination_id = request.args.get("destination_id")
    category = request.args.get("category")

    if not destination_type or not destination_id or not category:
        return jsonify({"error": "Missing required parameters"}), 400

    # Fetch raw materials with minimum stock details
    rm = get_raw_materials_stock_report(destination_type, destination_id, category)

    return jsonify(rm)  # Return as JSON response

# Utility function for converting metric units


def convert_to_base_units(quantity, metric):
    if metric == "grams":
        return quantity / 1000  # Convert grams to kg
    elif metric == "ml":
        return quantity / 1000  # Convert ml to liters
    return quantity  # Return as is for kg, liters, and units


@app.route('/transfer_raw_material', methods=['GET', 'POST'])
def transfer_raw_material():
    if "user" not in session:
        return redirect("/login")

    if request.method == 'POST':
        source_storeroom_id = request.form.get("storageroom")
        destination_type = request.form.get("destination_type")
        destination_id = request.form.get("destination_name")
        transfer_date = request.form.get("transfer_date")
        raw_materials = request.form.getlist("raw_material_id[]")
        quantities = request.form.getlist("quantity[]")
        metrics = request.form.getlist("metric[]")
        transfer_datetime = get_current_datetime()
        connection = get_db_connection()

        try:
            with connection.cursor() as cursor:
                # Step 1: Get the latest transfer_id for today
                cursor.execute("""
                    SELECT IFNULL(MAX(transfer_id), 0) + 1
                    FROM raw_material_transfer_details
                    WHERE transferred_date = %s
                    AND source_storage_room_id = %s
                """, (transfer_date, source_storeroom_id))
                next_transfer_id = cursor.fetchone()[0]  # Get next transfer ID

                # Step 2: Prepare Transfer Details
                transfer_details = [
                    (source_storeroom_id, destination_type, destination_id,
                     raw_material, Decimal(convert_to_base_units(quantity, metric)),
                     metric, transfer_date, transfer_datetime, next_transfer_id)
                    for raw_material, quantity, metric in zip(raw_materials, quantities, metrics)
                ]

                # Step 3: Bulk INSERT into `raw_material_transfer_details`
                insert_transfer_sql = """
                    INSERT INTO raw_material_transfer_details
                        (source_storage_room_id, destination_type, destination_id,
                        raw_material_id, quantity, metric, transferred_date, transfer_time, transfer_id)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                """
                cursor.executemany(insert_transfer_sql, transfer_details)

                # Step 4: Update inventory_stock
                raw_material_ids = [item[3] for item in transfer_details]
                raw_material_ids_str = ",".join(map(str, raw_material_ids))  # Convert to comma-separated string

                case_statements_outgoing = " ".join([f"WHEN {item[3]} THEN {item[4]}" for item in transfer_details])
                case_statements_available = case_statements_outgoing  # Same logic for both columns

                update_inventory_sql = f"""
                    UPDATE inventory_stock
                    SET 
                        outgoing_stock = outgoing_stock + CASE raw_material_id 
                            {case_statements_outgoing} ELSE outgoing_stock END,
                        currently_available = currently_available - CASE raw_material_id 
                            {case_statements_available} ELSE 0 END,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE destination_type = 'storageroom' 
                    AND destination_id = %s
                    AND raw_material_id IN ({raw_material_ids_str})
                """

                cursor.execute(update_inventory_sql, (source_storeroom_id,))

                # Step 5: Fetch current inventory details
                fetch_inventory_sql = f"""
                    SELECT raw_material_id, 
                        IFNULL(currently_available, 0),
                        IFNULL(minimum_quantity, 0), 
                        IFNULL(quantity_needed, 0) 
                    FROM inventory_stock 
                    WHERE destination_type = %s 
                    AND destination_id = %s 
                    AND raw_material_id IN ({raw_material_ids_str})
                """

                cursor.execute(fetch_inventory_sql, (destination_type, destination_id))
                existing_inventory = {row[0]: (Decimal(row[1]), Decimal(row[2]), Decimal(row[3]))
                                      for row in cursor.fetchall()}  # Convert to Decimal

                # Step 6: Bulk INSERT or UPDATE inventory_stock
                insert_inventory_sql = """
                    INSERT INTO inventory_stock
                        (destination_type, destination_id, raw_material_id, metric,
                        incoming_stock, currently_available, minimum_quantity, quantity_needed, updated_at)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, CURRENT_TIMESTAMP)
                    ON DUPLICATE KEY UPDATE
                        incoming_stock = incoming_stock + VALUES(incoming_stock),
                        currently_available = COALESCE(currently_available, 0) + VALUES(incoming_stock),
                        updated_at = CURRENT_TIMESTAMP
                """

                inventory_values = [
                    (item[1], item[2], item[3], item[5], Decimal(item[4]),  # Ensure quantity is Decimal
                     existing_inventory.get(item[3], (Decimal(0), Decimal(0), Decimal(0)))[
                        0] + Decimal(item[4]),  # Compute currently_available
                     existing_inventory.get(item[3], (Decimal(0), Decimal(0), Decimal(0)))[
                        1],  # Fetch minimum_quantity if exists, else 0
                     existing_inventory.get(item[3], (Decimal(0), Decimal(0), Decimal(0)))[2])  # Fetch quantity_needed if exists, else 0
                    for item in transfer_details
                ]

                cursor.executemany(insert_inventory_sql, inventory_values)

                connection.commit()
                flash(f"Transfer successful (Transfer ID: {next_transfer_id})", "success")

        except Exception as e:
            connection.rollback()
            app.logger.error(f"Database Error: {e}")
            flash(f"An error occurred: {e}", "danger")

        finally:
            connection.close()

        return redirect('/transfer_raw_material')

    # GET request - Load necessary data
    return render_template(
        'transfer_raw_material.html',
        raw_materials=get_all_rawmaterials(),
        storage_rooms=get_all_storagerooms(only_active=True),
        restaurants=get_all_restaurants(only_active=True),
        kitchens=get_all_kitchens(only_active=True),
        user=session["user"],
        today_date=get_current_date()
    )


@app.route('/list_rawmaterial_transfers', methods=["GET", "POST"])
def list_rawmaterial_transfers():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        selected_date = request.form['transfer_date']
        transfers = get_rawmaterial_transfer_history(selected_date)
        return render_template('list_rawmaterial_transfers.html', transfers=transfers, current_date=selected_date, user=session["user"])
    return render_template('list_rawmaterial_transfers.html', user=session["user"])


@app.route('/list_prepared_dishes_transfers', methods=["GET", "POST"])
def list_prepared_dishes_transfers():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        selected_date = request.form['transfer_date']
        transfers = get_prepared_dishes_transfer_history(selected_date)
        return render_template('list_prepared_dishes_transfers.html', transfers=transfers, current_date=selected_date, user=session["user"])
    return render_template('list_prepared_dishes_transfers.html', user=session["user"])


@app.route('/profile', methods=['GET', 'POST'])
def profile():
    if "user" not in session:
        return redirect("/login")
    user = get_user_by_email(session["user"]["email"])
    return render_template('profile.html', user=user)


@app.route('/logout')
def logout():
    if "user" not in session:
        return redirect("/login")
    session.pop("user")
    return redirect("/login")


def convert_to_base_unit(quantity, metric):
    """Converts the given quantity to its base unit (grams or ml)."""
    conversions = {
        'kg': 1000,
        'grams': 1,
        'liter': 1000,
        'ml': 1,
        'unit': 1
    }
    return quantity * conversions.get(metric, 1)


def convert_to_original_unit(quantity, metric):
    """Converts the given quantity to its original unit (grams or ml)."""
    conversions = {
        'kg': 1000,
        'grams': 1,
        'liter': 1000,
        'ml': 1,
        'unit': 1
    }
    return quantity // conversions.get(metric, 1)


@app.route('/estimate_dishes', methods=['GET', 'POST'])
def estimate_dishes():
    estimates_data = []
    if request.method == "POST":
        selected_date = request.form.get('date')
        # selected_date = '2024-12-29'

        if not selected_date:
            return jsonify({"error": "Please provide a valid date."}), 400

        try:
            connection = get_db_connection()
            with connection.cursor() as cursor:
                # Query transferred raw materials on the selected date
                transfer_query = """
                    SELECT raw_material_id, raw_material_name, SUM(quantity) as total_quantity, metric
                    FROM raw_material_transfer
                    WHERE transaction_date = %s
                    GROUP BY raw_material_id, raw_material_name, metric
                """
                cursor.execute(transfer_query, (selected_date,))
                transferred_materials = cursor.fetchall()

                if not transferred_materials:
                    return jsonify({"message": "No data available for the selected date."})

                # Convert transferred materials to a dictionary
                material_map = {}
                for material in transferred_materials:
                    material_map[material[0]] = {
                        'name': material[1],
                        'quantity': convert_to_base_unit(material[2], material[3]),
                        'metric': material[3]
                    }

                # Query all dishes and their required raw materials
                dishes_query = """
                    SELECT d.id AS dish_id, d.name AS dish_name, drm.raw_material_id, drm.quantity, drm.metric
                    FROM dishes d
                    JOIN dish_raw_materials drm ON d.id = drm.dish_id
                """
                cursor.execute(dishes_query)
                dish_data = cursor.fetchall()
                # Calculate estimates for each dish
                dish_estimates = {}

                for dish in dish_data:
                    dish_id = dish[0]
                    dish_name = dish[1]
                    raw_material_id = dish[2]

                    # Skip if raw material is not available in the transferred data
                    if raw_material_id not in material_map:
                        continue

                    # Convert required raw material quantity to base unit
                    required_quantity = convert_to_base_unit(dish[3], dish[4])

                    # Calculate max dishes that can be prepared with available material
                    available_quantity = material_map[raw_material_id]['quantity']
                    max_dishes = float(available_quantity) // float(required_quantity)

                    if dish_id not in dish_estimates:
                        dish_estimates[dish_id] = {
                            'name': dish_name,
                            'raw_materials': [],
                            'estimate': max_dishes
                        }
                    else:
                        dish_estimates[dish_id]['estimate'] = min(dish_estimates[dish_id]['estimate'], max_dishes)

                    # Add raw material details
                    dish_estimates[dish_id]['raw_materials'].append({
                        'name': material_map[raw_material_id]['name'],
                        'quantity_used': convert_to_original_unit(available_quantity, material_map[raw_material_id]['metric']),
                        'metric': material_map[raw_material_id]['metric']
                    })

                # Prepare the estimates_data
                estimates_data = []
                for dish_id, details in dish_estimates.items():
                    estimates_data.append({
                        'dish_name': details['name'],
                        'raw_materials': details['raw_materials'],
                        'estimate': details['estimate']
                    })

                return render_template("estimate_dishes.html", user=session["user"], estimates=estimates_data, selected_date=None)

        except Exception as e:
            return jsonify({"error": str(e)}), 500

        finally:
            connection.close()
    return render_template("estimate_dishes.html", user=session["user"], estimates=estimates_data, selected_date=None)


@app.route('/upload_sales_report', methods=['GET', 'POST'])
def upload_sales_report():
    if "user" not in session:
        return redirect("/login")

    if request.method == 'POST':
        file = request.files.get('file')
        restaurant_id = request.form.get("restaurant_id")
        sales_date = request.form.get("sales_report_date")

        if 'file' not in request.files:
            flash('No file part found. Please try again.', "danger")
            return redirect(url_for('upload_sales_report'))

        if file.filename == '':
            flash('No selected file. Please upload a file', "danger")
            return redirect(url_for('upload_sales_report'))

        if file and file.filename.endswith('.xlsx'):
            # Save the file
            file_path = os.path.join(app.config['UPLOAD_FOLDER'], file.filename)
            file.save(file_path)

            # Process the file
            missing_recipes = process_data(file_path)

            if missing_recipes:
                missing_recipes_table = """
                    <table class="table table-bordered">
                        <thead>
                            <tr>
                                <th>Missing Recipe</th>
                            </tr>
                        </thead>
                        <tbody>
                """
                for recipe in missing_recipes:
                    missing_recipes_table += f"<tr><td>{recipe}</td></tr>"
                missing_recipes_table += "</tbody></table>"

                flash(Markup(
                    f"Recipe not found for the following dishes. Kindly update recipe for all the dishes and continue:<br>{missing_recipes_table}"), "danger")
            else:
                # Process the data and update the daily_sales table
                df = pd.read_excel(file_path)
                # Extract sales date from filename format: Restaurant_item_tax_report_YYYY_MM_DD_HH_MM_SS.xlsx
                # filename_parts = file.filename.split('_')
                # sales_date_str = f"{filename_parts[4]}-{filename_parts[5]}-{filename_parts[6]}"
                # sales_date = datetime.strptime(sales_date_str, '%Y-%m-%d').date()

                conn = get_db_connection()
                cursor = conn.cursor()
                sales_report_data = []
                for index, row in df.iterrows():
                    temp = {}
                    temp["category"] = row['Category']
                    temp["item_name"] = row['Item Name']
                    temp["quantity"] = row['Qty']
                    cursor.execute(
                        "SELECT id FROM dishes WHERE category = %s AND name = %s", (temp["category"], temp["item_name"]))
                    dish = cursor.fetchone()
                    if dish:
                        dish_id = dish[0]
                        temp["dish_id"] = dish_id
                        cursor.execute("""
                            INSERT INTO daily_sales (sales_date, dish_id, restaurant_id, quantity)
                            VALUES (%s, %s, %s, %s)
                            ON DUPLICATE KEY UPDATE quantity = quantity + VALUES(quantity)
                        """, (sales_date, dish_id, restaurant_id, temp["quantity"]))
                    else:
                        missing_recipes.append(temp["item_name"])
                    sales_report_data.append(temp)

                conn.commit()
                cursor.close()
                conn.close()

                # Delete the uploaded Excel file
                os.remove(file_path)
                adjust_stocks(sales_report_data, sales_date, restaurant_id)
                flash("Sales report data has been processed succesfully and the inventory stocks have been adjusted accordingly. Please do not reupload the sales report as it will modify the inventory.", "success")
            return redirect(url_for('upload_sales_report'))

    restaurants = get_all_restaurants(only_active=True)
    return render_template('upload_sales_report.html', user=session["user"], restaurants=restaurants, current_date=get_current_date())


@app.route('/get_available_quantity', methods=['GET'])
def get_available_quantity():
    storageroom_id = int(request.args.get('storageroom_id'))
    raw_material_id = request.args.get('raw_material_id')
    available_quantity = get_storageroom_rawmaterial_quantity(storageroom_id, raw_material_id)
    storage_available_quantity = 0
    if available_quantity:
        storage_available_quantity = available_quantity[0]["quantity"]
    # # Check if storage room and raw material exist
    # available_quantity = storage_available_quantity.get(raw_material_id, 0)
    data = {"available_quantity": float(storage_available_quantity)}
    return jsonify(data)


@app.route('/add_prepared_dishes', methods=['GET', 'POST'])
def add_prepared_dishes():
    if "user" not in session:
        return redirect("/login")

    if request.method == "POST":
        # try:
        # Retrieve form data
        dish_categories = request.form.getlist('dish_categories[]')
        dish_names = request.form.getlist('dish_names[]')
        prepared_quantities = request.form.getlist('prepared_quantities[]')
        prepared_in_kitchen = request.form.get('kitchen_id')
        prepared_on = request.form.get('prepared_on')

        for category, dish, quantity in zip(dish_categories, dish_names, prepared_quantities):
            quantity = Decimal(quantity)
            # Validate dish existence
            dish_query = """
                SELECT id FROM dishes 
                WHERE category = %s AND name = %s
            """
            dish_data = fetch_one(dish_query, (category, dish))
            if not dish_data:
                flash(f"Dish '{dish}' under category '{category}' does not exist. Please add the dish.", "error")
                return redirect(request.url)
            dish_id = dish_data['id']

            # Check if the dish exists for the given kitchen and date
            existing_record = fetch_one(
                """
                SELECT id FROM kitchen_prepared_dishes 
                WHERE prepared_dish_id = %s AND prepared_in_kitchen = %s AND prepared_on = %s
                """,
                (dish_id, prepared_in_kitchen, prepared_on)
            )

            if existing_record:
                # Update quantity if record exists
                execute_query(
                    """
                    UPDATE kitchen_prepared_dishes 
                    SET prepared_quantity = prepared_quantity + %s, 
                        available_quantity = available_quantity + %s 
                    WHERE id = %s
                    """,
                    (quantity, quantity, existing_record['id'])
                )
            else:
                # Insert new record
                execute_query(
                    """
                    INSERT INTO kitchen_prepared_dishes 
                    (prepared_dish_id, prepared_quantity, available_quantity, prepared_in_kitchen, prepared_on) 
                    VALUES (%s, %s, %s, %s, %s)
                    """,
                    (dish_id, quantity, quantity, prepared_in_kitchen, prepared_on)
                )

            # Update kitchen stock
            update_kitchen_stock(prepared_in_kitchen, dish_id, quantity, prepared_on)

        flash("Prepared dishes added successfully!", "success")
        return redirect('/add_prepared_dishes')

        # except Exception as e:
        #     app.logger.error(f"Error while adding prepared dishes: {e}")
        #     flash("An error occurred while adding prepared dishes.", "error")
        #     return redirect(request.url)

    # GET request: fetch data for rendering the page
    dish_categories = get_unique_dish_categories()
    dishes = get_all_dishes()
    kitchens = get_all_kitchens(only_active=True)

    # Organize dishes by category
    dish_mapping = {}
    for dish in dishes:
        dish_mapping.setdefault(dish['category'], []).append(dish['name'])

    return render_template(
        'add_prepared_dishes.html',
        dish_categories=dish_categories,
        dish_mapping=dish_mapping,
        kitchens=kitchens,
        user=session["user"],
        todays_date=get_current_date()
    )


@app.route('/list_prepared_dishes', methods=['GET', 'POST'])
def list_prepared_dishes():
    if "user" not in session:
        return redirect("/login")
    if request.method == 'POST':
        prepared_date = request.form['prepared_date']
        prepared_dishes = get_all_prepared_dishes(prepared_date)
        return render_template('list_prepared_dishes.html', user=session["user"], prepared_dishes=prepared_dishes, current_date=prepared_date)
    return render_template('list_prepared_dishes.html', user=session["user"])


@app.route('/userlist', methods=['GET', 'POST'])
def userlist():
    if "user" not in session:
        return redirect("/login")
    users = get_all_users()

    return render_template('userlist.html', user=session["user"], users=users)


@app.route('/transfer_prepared_dishes', methods=['GET', 'POST'])
def transfer_prepared_dishes():
    if "user" not in session:
        return redirect("/login")

    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)

    # Fetch dishes, restaurants, and kitchens to populate in the form
    prepared_dishes_today = get_prepared_dishes_today()
    dish_categories = list(set([dish["prepared_dish_category"] for dish in prepared_dishes_today]))
    kitchens = get_all_kitchens(only_active=True)
    restaurants = get_all_restaurants(only_active=True)

    current_date = get_current_date()

    # Handle form submission for dish transfer
    if request.method == 'POST':
        source_kitchen_id = request.form['kitchen']

        destination_restaurant_id = request.form['destination_name']

        dish_categories = request.form.getlist('dish_categories[]')

        dish_names = request.form.getlist('dish_names[]')

        transferred_quantities = request.form.getlist('transferred_quantities[]')

        transfer_date = request.form['transfer_date']

        # try:
        conn = get_db_connection()
        cursor = conn.cursor()
        # Insert the transfer details into the database
        for category, name, quantity in zip(dish_categories, dish_names, transferred_quantities):
            dish_id = get_dish_details_from_category(category, name)[0]["id"]
            cursor.execute(
                """
                SELECT available_quantity FROM kitchen_prepared_dishes
                WHERE prepared_dish_id=%s AND prepared_in_kitchen = %s AND prepared_on=%s
                """,
                (dish_id, source_kitchen_id, transfer_date)
            )
            dish = cursor.fetchone()

            if dish and dish[0] >= int(quantity):
                cursor.execute("""
                INSERT INTO prepared_dish_transfer (
                    source_kitchen_id,
                    destination_restaurant_id,
                    dish_id,
                    quantity,
                    transferred_date
                ) VALUES (%s, %s, %s, %s, %s)
                ON DUPLICATE KEY UPDATE 
                    quantity = quantity + VALUES(quantity);
                """, (source_kitchen_id, destination_restaurant_id, dish_id, quantity, transfer_date))

                # Update the available quantity in the source kitchen
                cursor.execute(
                    """
                    UPDATE kitchen_prepared_dishes
                    SET available_quantity = available_quantity - %s
                    WHERE prepared_dish_id=%s AND prepared_in_kitchen = %s AND prepared_on=%s
                    """,
                    (quantity, dish_id, source_kitchen_id, transfer_date)
                )
                conn.commit()
            else:
                flash(f"Insufficient quantity for dish: {name} in category: {category}", "danger")
                conn.rollback()
                cursor.close()
                conn.close()
                return redirect(url_for('transfer_prepared_dishes'))

        flash("Dish transfer successful!", "success")

        # except Exception as e:
        #     conn.rollback()  # Rollback in case of any error
        #     app.logger.error(f"Error during dish transfer: {e}")
        #     flash("Error occurred while transferring the dish.", "danger")
        # finally:
        #     cursor.close()
        #     conn.close()

        return redirect(url_for('transfer_prepared_dishes'))

    return render_template('transfer_prepared_dishes.html', dish_categories=dish_categories, current_date=current_date, prepared_dishes_today=prepared_dishes_today, restaurants=restaurants, kitchens=kitchens, user=session["user"])


@app.route('/check_dish_availability', methods=['GET', 'POST'])
def check_dish_availability():
    if "user" not in session:
        return redirect("/login")
    if request.method == 'POST':
        selected_date = request.form['selected_date']
        restaurant_id = request.form['restaurant_id']

        # Establish DB connection
        conn = get_db_connection()
        cursor = conn.cursor(dictionary=True)

        # Query to get dish details for the selected restaurant and date
        query = """
        SELECT d.name, d.category, SUM(pdt.quantity) AS quantity_available
        FROM prepared_dish_transfer pdt
        JOIN dishes d ON pdt.dish_id = d.id
        WHERE pdt.destination_restaurant_id = %s
        AND pdt.transferred_date = %s
        GROUP BY pdt.dish_id
        """
        cursor.execute(query, (restaurant_id, selected_date))
        dishes = cursor.fetchall()

        cursor.close()
        conn.close()

        # Render the page with the fetched data
        return render_template('check_dish_availability.html', dishes=dishes, restaurants=get_restaurants(), user=session["user"])

    # Fetch restaurants to show in the dropdown
    return render_template('check_dish_availability.html', restaurants=get_restaurants(), user=session["user"])

# Function to fetch restaurant data for the dropdown


def get_restaurants():
    conn = get_db_connection()
    cursor = conn.cursor(dictionary=True)
    cursor.execute("SELECT id, restaurantname, restaurantcode FROM restaurant")
    restaurants = cursor.fetchall()
    cursor.close()
    conn.close()
    return restaurants


# Read the Excel file
def read_excel(file_path):
    return pd.read_excel(file_path)


def process_data(file_path):

    data = read_excel(file_path)
    missing_recipes = []

    for index, row in data.iterrows():
        category = row['Category']
        item_name = row['Item Name']
        # Find dish_id
        dish = get_dish_details_from_category(category, item_name)

        if dish:
            dish_id = dish[0]["id"]
            dish_recipe = get_dish_recipe(dish_id)
            if not dish_recipe:
                missing_recipes.append(f"{category} - {item_name}")
        else:
            missing_recipes.append(f"{category} - {item_name}")
    return missing_recipes


def adjust_stocks(sales_report_data, report_date, restaurant_id):
    conn = get_db_connection()
    if not conn:
        print("Failed to connect to the database.")
        return []

    # data = get_sales_report_data(report_date)
    for dish_data in sales_report_data:

        dish_recipe = get_dish_recipe(dish_data["dish_id"])

        transferred_dish = check_dish_transferred(dish_data["dish_id"], report_date, restaurant_id)
        if transferred_dish:
            pass
        else:
            update_restaurant_stock(restaurant_id, dish_data["dish_id"], dish_data["quantity"], report_date)
        #     materials = get_raw_materials(dish_data["dish_id"])
        #     raw_materials = []
        #     for material in materials:
        #         raw_materials.append({
        #             'raw_material_id': material[0],
        #             'quantity': material[1] * dish_data["quantity"],
        #             'metric': material[2]
        #         })
        #     subtract_raw_materials(raw_materials, "restaurant", restaurant_id, report_date)
        # # transferred_dish = check_dish_transferred(dish_data["id"], report_date, restaurant_id)
        # # if transferred_dish:
        # #     pass
        # #     # subtract_raw_materials(raw_materials, "kitchen", transferred_dish[0], report_date)

        # else:
        #     subtract_raw_materials(raw_materials, "restaurant", restaurant_id, report_date)


@app.route('/restaurant_consumption', methods=['GET', 'POST'])
def restaurant_consumption():
    if "user" not in session:
        return redirect("/login")
    restaurants = get_all_restaurants(only_active=True)
    if request.method == 'POST':
        selected_date = request.form['report_date']
        restaurant_id = request.form['restaurant_id']
        consumption_data = get_restaurant_consumption_report(restaurant_id, selected_date)
        return render_template("restaurant_consumption.html", user=session["user"], restaurants=restaurants, current_date=selected_date, query_result=consumption_data)
    return render_template("restaurant_consumption.html", user=session["user"], restaurants=restaurants, current_date=get_current_date())


@app.route('/kitchen_consumption', methods=['GET', 'POST'])
def kitchen_consumption():
    if "user" not in session:
        return redirect("/login")
    kitchens = get_all_kitchens(only_active=True)
    if request.method == 'POST':
        selected_date = request.form['report_date']
        kitchen_id = request.form['kitchen_id']
        consumption_data = get_kitchen_consumption_report(kitchen_id, selected_date)
        return render_template("kitchen_consumption.html", user=session["user"], kitchens=kitchens, current_date=selected_date, query_result=consumption_data)
    return render_template("kitchen_consumption.html", user=session["user"], kitchens=kitchens, current_date=get_current_date())


@app.route("/api/purchase_trend")
def purchase_trend():
    year = request.args.get("year", type=int)
    query = """
        SELECT MONTH(purchase_date) AS month, SUM(total_cost) AS purchase_amount
        FROM purchase_history
        WHERE YEAR(purchase_date) = %s
        GROUP BY MONTH(purchase_date)
        ORDER BY MONTH(purchase_date);
    """

    connection = get_db_connection()
    with connection.cursor() as cursor:
        cursor.execute(query, (year,))
        result = cursor.fetchall()

    connection.close()

    # Mapping database results to required format
    months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
    purchase_data = {row[0]: row[1] for row in result}

    purchase_amounts = [purchase_data.get(i+1, 0) for i in range(12)]  # Fill missing months with 0

    response = {
        "year": year,
        "months": months,
        "purchase_amounts": purchase_amounts
    }

    return jsonify(response)
    # return {
    #     "year": 2025,
    #     "months": ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    #     "purchase_amounts": [12000, 15000, 18000, 11000, 9000, 20000, 25000, 23000, 17000, 19000, 22000, 24000]
    # }


@app.route('/stock_report', methods=["GET", "POST"])
def stock_report():
    if "user" not in session:
        return redirect("/login")
    # if request.method == "POST":
    #     selected_date = request.form['transfer_date']
    #     transfers = get_prepared_dishes_transfer_history(selected_date)
    #     return render_template('stock_report.html', transfers=transfers, current_date=selected_date, user=session["user"])
    rm_categories = get_rawmaterial_category()
    rm_categories = [rmc[0] for rmc in rm_categories]
    contact_details = get_contact_details()
    return render_template('stock_report.html', user=session["user"], storage_rooms=get_all_storagerooms(only_active=True),
                           restaurants=get_all_restaurants(only_active=True),
                           kitchens=get_all_kitchens(only_active=True), rawmaterial_category=rm_categories, contact_details=contact_details)


@app.route('/transfer_raw_material_report', methods=["GET", "POST"])
def transfer_raw_material_report():
    if "user" not in session:
        return redirect("/login")
    contact_details = get_contact_details()
    return render_template('transfer_raw_material_report.html', user=session["user"], storage_rooms=get_all_storagerooms(only_active=True),
                           restaurants=get_all_restaurants(only_active=True),
                           kitchens=get_all_kitchens(only_active=True), contact_details=contact_details)


@app.route('/get_transfer_details_report', methods=["GET"])
def get_transfer_details():
    if "user" not in session:
        return redirect("/login")

    # Fetch query parameters from request
    storageroom_id = request.args.get("storageroom")
    destination_type = request.args.get("destination_type")
    destination_id = request.args.get("destination_name")
    transfer_date = request.args.get("transfer_date")
    transfer_id = request.args.get("transfer_id")

    if not destination_type or not destination_id or not storageroom_id or not transfer_date or not transfer_id:
        return jsonify({"error": "Missing required parameters"}), 400

    # Fetch raw material transfer details
    rm = get_transfer_raw_material_report(storageroom_id, destination_type, destination_id, transfer_date, transfer_id)

    return jsonify(rm)  # Return as JSON response


@app.route("/contact_details", methods=["GET", "POST"])
def contact_details():
    if "user" not in session:
        return redirect("/login")
    if request.method == "POST":
        name = request.form["name"].strip()
        contact_number = request.form["contact_number"].strip()
        address = request.form["address"].strip()

        insert_query = """
            INSERT INTO contact_details (name, contact_number, address)
            VALUES (%s, %s, %s)
        """
        if execute_query(insert_query, (name, contact_number, address)):
            flash("Details added successfully!", "success")
        else:
            flash("Error: Unable to add the details. Please try again later.", "danger")
        return redirect("/contact_details")
    contact_details = get_contact_details()
    return render_template("contact_details.html", user=session["user"], contact_details=contact_details)


@app.route('/deleteuser/<int:user_id>', methods=['DELETE'])
def delete_user(user_id):
    if "user" not in session:
        return redirect("/login")
    if delete_user_from_db(user_id):
        flash("User deleted successfully!", "success")
        return jsonify({"success": True}), 200
    else:
        flash("Error: Unable to delete the user!", "danger")
        return jsonify({"success": False, "message": "User not found"}), 404


@app.route('/deleterawmaterial/<int:rawmaterial_id>', methods=['DELETE'])
def delete_rawmaterial(rawmaterial_id):
    if "user" not in session:
        return redirect("/login")
    if delete_rawmaterial_from_db(rawmaterial_id):
        flash("Rawmaterial deleted successfully!", "success")
        return jsonify({"success": True}), 200
    else:
        flash("Error: Unable to delete the rawmaterial!", "danger")
        return jsonify({"success": False, "message": "Unable to delete the rawmaterial"}), 404


@app.route('/get_transfer_ids', methods=['GET'])
def get_transfer_ids():
    transfer_ids_list = []
    storageroom_id = request.args.get('storageroom')
    destination_type = request.args.get('destination_type')
    destination_name = request.args.get('destination_name')
    transfer_date = request.args.get('transfer_date')

    if not storageroom_id or not destination_type or not destination_name or not transfer_date:
        return jsonify([])  # Return an empty list if any field is missing

    try:
        conn = get_db_connection()
        cursor = conn.cursor()

        query = """
        SELECT DISTINCT transfer_id FROM raw_material_transfer_details
        WHERE source_storage_room_id = %s 
        AND destination_type = %s 
        AND destination_id = %s
        AND DATE(transferred_date) = %s
        ORDER BY transfer_id ASC
        """
        cursor.execute(query, (storageroom_id, destination_type, destination_name, transfer_date))
        transfer_ids = cursor.fetchall()

        conn.close()

        # Add "All" and "Total" options
        if transfer_ids:
            transfer_ids_list = [{"transfer_id": "all"}, {"transfer_id": "total"}]
            transfer_ids_list += [{"transfer_id": row[0]} for row in transfer_ids]

        return jsonify(transfer_ids_list)

    except Exception as e:
        app.logger.error(f"Error fetching transfer IDs: {e}")
        return jsonify({"error": "Internal Server Error"}), 500


@app.route("/delete_purchase_record", methods=["GET", "POST"])
def delete_purchase_record():
    if "user" not in session:
        return redirect("/login")
    today_date = get_current_date()
    # today_date = '2025-03-25'
    todays_purchase = get_cumulative_purchase_record_invoice_wise(today_date)
    return render_template("delete_purchase_record.html", user=session["user"], today_date=today_date, todays_purchase=todays_purchase)


@app.route("/delete_purchase_and_adjust_stock", methods=["DELETE"])
def delete_purchase_and_adjust_stock():
    data = request.get_json()
    vendor_id = data.get("vendor_id")
    invoice_number = data.get("invoice_number")
    storageroom_id = data.get("storageroom_id")
    purchase_date = data.get("purchase_date")

    if not all([vendor_id, invoice_number, storageroom_id, purchase_date]):
        flash("Missing required parameters", "danger")
        return jsonify({"success": False, "message": "Missing required parameters"}), 400

    conn = get_db_connection()
    cursor = conn.cursor()

    try:
        # Fetch all raw materials associated with the purchase
        cursor.execute("""
            SELECT raw_material_id, quantity 
            FROM purchase_history 
            WHERE vendor_id = %s AND invoice_number = %s AND purchase_date = %s
        """, (vendor_id, invoice_number, purchase_date))

        purchase_records = cursor.fetchall()

        if not purchase_records:
            return jsonify({"success": False, "message": "No matching purchase records found"}), 404

        # Adjust inventory_stock for each raw material
        for record in purchase_records:
            raw_material_id = record[0]
            quantity = record[1]

            cursor.execute("""
                UPDATE inventory_stock 
                SET incoming_stock = incoming_stock - %s, 
                    currently_available = currently_available - %s 
                WHERE raw_material_id = %s AND destination_type = 'storageroom' AND destination_id = %s
            """, (quantity, quantity, raw_material_id, storageroom_id))
        # Delete purchase records after stock adjustment
        cursor.execute("""
            DELETE FROM purchase_history 
            WHERE vendor_id = %s AND invoice_number = %s AND purchase_date = %s
        """, (vendor_id, invoice_number, purchase_date))

        # Delete associated payment records
        cursor.execute("""
            DELETE FROM vendor_payment_tracker
            WHERE vendor_id = %s AND invoice_number = %s AND purchase_date = %s
        """, (vendor_id, invoice_number, purchase_date))

        cursor.execute("""
            DELETE FROM payment_records
            WHERE vendor_id = %s AND invoice_number = %s AND purchase_date = %s
        """, (vendor_id, invoice_number, purchase_date))
        conn.commit()  # Commit the transaction only if everything is successful
        flash("Purchase deleted and stock adjusted successfully!", "success")
        return jsonify({"success": True, "message": "Purchase deleted and stock adjusted."})

    except Exception as e:
        conn.rollback()  # Rollback in case of an error
        app.logger.error(f"Failed to delete purchase record {str(e)}")
        flash("Failed to delete purchase record", "danger")
        return jsonify({"success": False, "message": f"Error: {str(e)}"}), 500

    finally:
        cursor.close()
        conn.close()


if __name__ == "__main__":
    app.run()
